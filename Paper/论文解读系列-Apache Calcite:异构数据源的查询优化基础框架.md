Apache Calcite 是一个基础软件框架，能够为许多流行的开源数据处理系统提供查询处理、查询优化以及查询语言的支持，例如 Apache Hive、Apache Storm、Apache Flink、Druid 以及 MapD 等等。Calcite 的架构包含查询优化器、查询处理器以及适配器：模块化以及可扩展的查询优化器内置了上百种优化规则；查询处理器可以支持各种查询语言；为扩展性设计的适配器可以支持各种异构数据模型或存储(关系型、半结构化、流式以及地理空间数据等)。这种灵活、可嵌入且可扩展的架构设计使得 Apache Calcite 在大数据处理框架上成为一个很好的选择。Apache Calcite 目前是一个比较活跃的项目，将会持续引入对新类型数据源、查询语言以及查询处理和优化方法的支持。


本篇论文主要章节安排如下：
- 第 1 节介绍 Calcite 的开发背景
- 第 2 节讨论 Calcite 相关工作
- 第 3 节介绍 Calcite 的架构及其主要组件
- 第 4 节描述 Calcite 核心的关系代数
- 第 5 节介绍 Calcite 的适配器，这是一种定义如何读取外部数据源的抽象
- 第 6 节描述 Calcite 的优化器及其主要特性
- 第 7 节介绍 Calcite 处理不同查询处理范式的扩展
- 第 8 节概述了已经使用 Calcite 的数据处理系统
- 第 9 节讨论了框架未来的扩展

## 1. 介绍

在开创性的 System R 之后，传统的关系数据库引擎主导了数据处理领域。然而，早在 2005 年，Stonebraker 和 Çetintemel 就预测我们会看到一系列有特性的引擎的出现，例如列式存储，流处理引擎，文本搜索引擎等等。他们认为这些专用的引擎可以提供更具成本效益的性能，并且终结 `One size fits all` 的模式。现在许多专门的开源数据系统已经变得流行，如 Storm 和 Flink（流处理），Elasticsearch（文本搜索），Apache Spark，Druid 等。随着组织投资于针对其特定需求量身定制的数据处理系统，出现了两个主要问题：
- 这些专用系统的开发人员会遇到查询优化的问题、需要像 SQL 以及相关扩展(例如流查询、LINQ 的语言集成查询)查询语言的支持。如果没有统一的框架，每个开发工程师都独立开发类似的优化逻辑和语言支持会大大浪费人力。
- 使用这些专用系统的程序员通常必须将其中的几个集成在一起使用。可能依赖 Elasticsearch，Apache Spark 或者 Druid。我们需要构建能够支持跨异构数据源的优化查询的系统。

Apache Calcite 是为解决这些问题而开发的。它是一个完整的查询处理系统，提供许多常见功能：查询执行，查询优化以及查询语言，这是任何数据库管理系统都需要的功能，但是不提供数据存储和管理功能，留给专用引擎来实现。Calcite 很快被 Hive、Drill、Storm 以及许多其他数据处理引擎采用了，为它们提供了高级查询优化和查询语言。例如，Hive 是一个建立在 Apache Hadoop 之上的流行数据仓库项目。随着 Hive 从批处理转向交互式 SQL 查询平台，很明显这个项目核心需要一个强大的优化器。因此，Hive 采用了 Calcite 作为它的优化器，并且它们之间的集成一直在持续增长。许多其他项目和产品也纷纷效仿，包括 Flink，MapD 等。

此外，Calcite 通过向多个系统暴露一个通用接口来实现跨平台优化。为了保证效率，优化器需要全局推理，例如，在物化视图跨不同系统中做出决策。建立一个通用框架并非没有挑战。特别是，框架需要有足够的可扩展性和灵活性来适应需要集成的不同类型的系统。我们相信如下特性有助于 Calcite 在开源社区和行业中的广泛采用：
- 开源友好
  - 过去十年中，许多主要的数据处理平台要么是开源的，要么很大程度上是基于开源的。Calcite 是一个 Apache 软件基金会(ASF)孵化的开源的框架，提供了协作开发项目的手段。此外，该软件由 Java 编写，更易与许多最新的数据处理系统（它们也大都由 Java 编写）进行集成，尤其是那些在 Hadoop 生态系统里的。
- 多种数据模型
  - Calcite 提供对查询优化和查询语言的支持，同时使用流和常规数据处理范例。Calcite 将流视为有时间顺序的记录或事件集合，这些记录或事件不像传统数据处理系统那样持久保存到磁盘。
- 灵活的查询优化器
  - 从规则到成本模型，优化器的每个组件都是可插拔和可扩展的。此外，Calcite 还支持多个计划引擎。因此，优化可以分解为由不同优化引擎处理的阶段，这取决于哪一个最适合该阶段。
- 跨系统支持
  - Calcite 框架可以跨多个查询处理系统和数据库后端来运行和优化查询。
- 可靠性
  - Calcite 是可靠的，因为它多年来的广泛使用导致了该平台的详尽测试。Calcite 还包含了一个涵盖很广的测试套件，用于验证系统的所有组件，包括查询优化器规则以及与后端数据源的集成。
- 支持 SQL 以及扩展
  - 许多系统都不提供自己的查询语言，而是更喜欢依赖现有的查询语言，例如 SQL。Calcite 提供对 ANSI 标准 SQL 的支持，以及各种 SQL 方言和扩展，例如，用于表达对流或嵌套数据的查询。此外，Calcite 还包含符合标准 Java API（JDBC）的驱动程序。

## 2. 相关工作

虽然 Calcite 目前是 Hadoop 生态系统中应用最广泛的大数据分析优化器，但其背后的许多思想并不新颖。例如，查询优化器基于来自 Volcano 和 Cascade 框架的思想构建，并结合其他广泛使用的优化技术，例如物化视图重写。还有其他系统试图填补与 Calcite 类似的角色。

Orca 是用于 Greenplum 和 HAWQ 等数据管理产品的模块化查询优化器。Orca 实现了一个框架，用于在两种已知的 Data eXchange Language 之间交换信息，从而将优化器与查询执行引擎解耦。Orca 还提供了用于验证生成的查询计划的正确性和性能的工具。与 Orca 不同的是，Calcite 还可以作为一个独立的查询执行引擎，可以与多个存储和处理后端，包括可插拔的规划器和优化器配合使用。

Spark SQL 扩展了 Apache Spark 以支持 SQL 查询执行，这也可以像在 Calcite 中一样对多个数据源执行查询。但是 Spark SQL 中的 Catalyst 优化器虽然也试图最小化查询执行成本，但缺少 Calcite 中使用的动态编程方法，并且容易陷入局部最小值的风险。

Algebricks 是一种查询编译器体系结构，为大数据查询处理提供数据模型无关的代数层和编译器框架。高级语言被编译为 Algebricks 逻辑代数。然后 Algebricks 生成针对 Hyracks 并行处理后端的优化作业。虽然 Calcite 与 Algebricks 共享模块化方法，但 Calcite 还支持基于成本的优化。在当前版本的 Calcite 中，查询优化器架构使用基于 Volcano 的基于动态编程的规划，以及 Orca 中的多阶段优化扩展。虽然原则上 Algebricks 可以支持多个处理后端（例如，Apache Tez，Spark），但是 Calcite 多年来为各种后端提供了经过充分测试的支持。

Garlic 是一个异构数据管理系统，它表示统一对象模型下来自多个系统的数据。但是，Garlic 不支持跨不同系统的查询优化，并依赖于每个系统来优化自己的查询。

FORWARD 是一个联合查询处理器，它实现了 SQL 的超集，称为 SQL++。SQL++ 有一个半结构化数据模型，它集成了 JSON 和关系数据模型，而 Calcite 通过在查询规划期间在关系数据模型中表示它们来支持半结构化数据模型。FORWARD 将用 SQL++ 编写的联合查询分解为子查询，并根据查询计划在底层数据库上执行它们。数据的合并发生在 FORWARD 引擎内部。

另一个联合数据存储和处理系统是 BigDAWG，它抽象了广泛的数据模型，包括关系，时间序列和流。BigDAWG 中的抽象单元称为信息孤岛。每个信息孤岛都有查询语言，数据模型并连接到一个或多个存储系统。在单个信息孤岛的范围内支持跨存储系统查询。Calcite 提供了统一的关系抽象，允许使用不同的数据模型查询后端。

Myria 是用于大数据分析的通用引擎，具有对 Python 语言的高级支持。它为其他后端引擎（如Spark和PostgreSQL）生成查询计划。

## 3. 架构

Apache Calcite 包含了许多传统数据库管理系统所具备的组件，但同时也丢弃了一些关键组件，例如数据存储、处理数据的算法以及用于存储元数据的存储库。Calcite 是有意丢弃这些组件的，这样能让 Calcite 成为衔接多数据存储以及多数据处理引擎的一种更好的选择，同时也为构建定制化的数据处理系统提供坚实的基础。

![](1)

上图展示了 Apache Calcite 架构的主要组成组件。Calcite 采用关系操作树作为其内部表示。优化引擎主要包括三个组件：规则，元数据提供程序以及计划引擎，我们将在第 6 节详细讨论这些组件。图中虚线表示与外部框架的交互，Caclcite 提供了多种方式与外部框架交互。

首先，Calcite 包含一个查询解析器和验证器，可以将 SQL 查询转换为关系操作树。由于 Calcite 不包含存储层，它提供了一种机制，可以通过适配器在外部存储引擎中定义模式 Schema 和视图(第 5 节会详细介绍)，因此 Calcite 可以在这些引擎之上使用。其次，尽管 Calcite 为需要这种数据库语言支持的系统提供了优化的 SQL 支持，但它也为已经拥有自己的语言解析和解释的系统提供了优化支持：
- 有些系统支持 SQL 查询，但是没有或者只是有限的 SQL 查询优化。例如，Hive 和 Spark 最初均提供了对 SQL 查询的支持，但是它们并没有优化器。对于这种情况，一旦查询被优化后，Calcite 就可以将关系表达式转回 SQL。这种特性使得 Calcite 能够作为独立的系统在在那些有 SQL 接口，但无优化器的数据管理系统之上运行。
- Calcite 架构不仅仅面向 SQL 查询优化。数据处理系统通常会为他们自己的查询语言选择他们自己的解析器。对于这种情况，Calcite 也能起作用。实际上，Calcite 还允许通过直接实例化关系操作来轻松地构造操作树。可以使用内置的关系表达式 Builder 接口来实现。例如，假设我们想使用表达式构建器表达以下 Apache Pig 脚本：
```
emp = LOAD 'employee_data' AS (deptno, sal);
emp_by_dept = GROUP emp by (deptno);
emp_agg = FOREACH emp_by_dept GENERATE GROUP as deptno, COUNT(emp.sal) AS c, SUM(emp.sal) as s;
dump emp_agg;
```
使用 Calcite 构建器来表示，具体如下：
```java
final RelNode node = builder.scan("employee_data")
    .aggregate(builder.groupKey("deptno"),
               builder.count(false, "c"),
               builder.sum(false, "s", builder.field("sal")))
    .build();
```
该接口展示了构建关系表达式所需的主要部分。优化阶段完成后，应用程序可以检索优化的关系表达式，然后可以将其映射回系统的查询处理单元。







原文：[Apache Calcite: A Foundational Framework for Optimized Query Processing Over Heterogeneous Data Sources](https://arxiv.org/pdf/1802.10233.pdf)
