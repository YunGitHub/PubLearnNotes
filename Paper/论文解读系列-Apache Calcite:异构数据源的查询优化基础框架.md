Apache Calcite 是一个基础软件框架，能够为许多流行的开源数据处理系统提供查询处理、查询优化以及查询语言的支持，例如 Apache Hive、Apache Storm、Apache Flink、Druid 以及 MapD 等等。Calcite 的架构包含查询优化器、查询处理器以及适配器：模块化以及可扩展的查询优化器内置了上百种优化规则；查询处理器可以支持各种查询语言；为扩展性设计的适配器可以支持各种异构数据模型或存储(关系型、半结构化、流式以及地理空间数据等)。这种灵活、可嵌入且可扩展的架构设计使得 Apache Calcite 在大数据处理框架上成为一个很好的选择。Apache Calcite 目前是一个比较活跃的项目，将会持续引入对新类型数据源、查询语言以及查询处理和优化方法的支持。


本篇论文主要章节安排如下：
- 第 1 节介绍 Calcite 的开发背景
- 第 2 节讨论 Calcite 相关工作
- 第 3 节介绍 Calcite 的架构及其主要组件
- 第 4 节描述 Calcite 核心的关系代数
- 第 5 节介绍 Calcite 的适配器，这是一种定义如何读取外部数据源的抽象
- 第 6 节描述 Calcite 的优化器及其主要特性
- 第 7 节介绍 Calcite 处理不同查询处理范式的扩展
- 第 8 节概述了已经使用 Calcite 的数据处理系统
- 第 9 节讨论了框架未来的扩展

## 1. 介绍

在开创性的 System R 之后，传统的关系数据库引擎主导了数据处理领域。然而，早在 2005 年，Stonebraker 和 Çetintemel 就预测我们会看到一系列有特性的引擎的出现，例如列式存储，流处理引擎，文本搜索引擎等等。他们认为这些专用的引擎可以提供更具成本效益的性能，并且终结 `One size fits all` 的模式。现在许多专门的开源数据系统已经变得流行，如 Storm 和 Flink（流处理），Elasticsearch（文本搜索），Apache Spark，Druid 等。随着组织投资于针对其特定需求量身定制的数据处理系统，出现了两个主要问题：
- 这些专用系统的开发人员会遇到查询优化的问题、需要像 SQL 以及相关扩展(例如流查询、LINQ 的语言集成查询)查询语言的支持。如果没有统一的框架，每个开发工程师都独立开发类似的优化逻辑和语言支持会大大浪费人力。
- 使用这些专用系统的程序员通常必须将其中的几个集成在一起使用。可能依赖 Elasticsearch，Apache Spark 或者 Druid。我们需要构建能够支持跨异构数据源的优化查询的系统。

Apache Calcite 是为解决这些问题而开发的。它是一个完整的查询处理系统，提供许多常见功能：查询执行，查询优化以及查询语言，这是任何数据库管理系统都需要的功能，但是不提供数据存储和管理功能，留给专用引擎来实现。Calcite 很快被 Hive、Drill、Storm 以及许多其他数据处理引擎采用了，为它们提供了高级查询优化和查询语言。例如，Hive 是一个建立在 Apache Hadoop 之上的流行数据仓库项目。随着 Hive 从批处理转向交互式 SQL 查询平台，很明显这个项目核心需要一个强大的优化器。因此，Hive 采用了 Calcite 作为它的优化器，并且它们之间的集成一直在持续增长。许多其他项目和产品也纷纷效仿，包括 Flink，MapD 等。

此外，Calcite 通过向多个系统暴露一个通用接口来实现跨平台优化。为了保证效率，优化器需要全局推理，例如，在物化视图跨不同系统中做出决策。建立一个通用框架并非没有挑战。特别是，框架需要有足够的可扩展性和灵活性来适应需要集成的不同类型的系统。我们相信如下特性有助于 Calcite 在开源社区和行业中的广泛采用：
- 开源友好
  - 过去十年中，许多主要的数据处理平台要么是开源的，要么很大程度上是基于开源的。Calcite 是一个 Apache 软件基金会(ASF)孵化的开源的框架，提供了协作开发项目的手段。此外，该软件由 Java 编写，更易与许多最新的数据处理系统（它们也大都由 Java 编写）进行集成，尤其是那些在 Hadoop 生态系统里的。
- 多种数据模型
  - Calcite 提供对查询优化和查询语言的支持，同时使用流和常规数据处理范例。Calcite 将流视为有时间顺序的记录或事件集合，这些记录或事件不像传统数据处理系统那样持久保存到磁盘。
- 灵活的查询优化器
  - 从规则到成本模型，优化器的每个组件都是可插拔和可扩展的。此外，Calcite 还支持多个计划引擎。因此，优化可以分解为由不同优化引擎处理的阶段，这取决于哪一个最适合该阶段。
- 跨系统支持
  - Calcite 框架可以跨多个查询处理系统和数据库后端来运行和优化查询。
- 可靠性
  - Calcite 是可靠的，因为它多年来的广泛使用导致了该平台的详尽测试。Calcite 还包含了一个涵盖很广的测试套件，用于验证系统的所有组件，包括查询优化器规则以及与后端数据源的集成。
- 支持 SQL 以及扩展
  - 许多系统都不提供自己的查询语言，而是更喜欢依赖现有的查询语言，例如 SQL。Calcite 提供对 ANSI 标准 SQL 的支持，以及各种 SQL 方言和扩展，例如，用于表达对流或嵌套数据的查询。此外，Calcite 还包含符合标准 Java API（JDBC）的驱动程序。

## 2. 相关工作

虽然 Calcite 目前是 Hadoop 生态系统中应用最广泛的大数据分析优化器，但其背后的许多思想并不新颖。例如，查询优化器基于来自 Volcano 和 Cascade 框架的思想构建，并结合其他广泛使用的优化技术，例如物化视图重写。还有其他系统试图填补与 Calcite 类似的角色。

Orca 是用于 Greenplum 和 HAWQ 等数据管理产品的模块化查询优化器。Orca 实现了一个框架，用于在两种已知的 Data eXchange Language 之间交换信息，从而将优化器与查询执行引擎解耦。Orca 还提供了用于验证生成的查询计划的正确性和性能的工具。与 Orca 不同的是，Calcite 还可以作为一个独立的查询执行引擎，可以与多个存储和处理后端，包括可插拔的规划器和优化器配合使用。

Spark SQL 扩展了 Apache Spark 以支持 SQL 查询执行，这也可以像在 Calcite 中一样对多个数据源执行查询。但是 Spark SQL 中的 Catalyst 优化器虽然也试图最小化查询执行成本，但缺少 Calcite 中使用的动态编程方法，并且容易陷入局部最小值的风险。

Algebricks 是一种查询编译器体系结构，为大数据查询处理提供数据模型无关的代数层和编译器框架。高级语言被编译为 Algebricks 逻辑代数。然后 Algebricks 生成针对 Hyracks 并行处理后端的优化作业。虽然 Calcite 与 Algebricks 共享模块化方法，但 Calcite 还支持基于成本的优化。在当前版本的 Calcite 中，查询优化器架构使用基于 Volcano 的基于动态编程的规划，以及 Orca 中的多阶段优化扩展。虽然原则上 Algebricks 可以支持多个处理后端（例如，Apache Tez，Spark），但是 Calcite 多年来为各种后端提供了经过充分测试的支持。

Garlic 是一个异构数据管理系统，它表示统一对象模型下来自多个系统的数据。但是，Garlic 不支持跨不同系统的查询优化，并依赖于每个系统来优化自己的查询。

FORWARD 是一个联合查询处理器，它实现了 SQL 的超集，称为 SQL++。SQL++ 有一个半结构化数据模型，它集成了 JSON 和关系数据模型，而 Calcite 通过在查询规划期间在关系数据模型中表示它们来支持半结构化数据模型。FORWARD 将用 SQL++ 编写的联合查询分解为子查询，并根据查询计划在底层数据库上执行它们。数据的合并发生在 FORWARD 引擎内部。

另一个联合数据存储和处理系统是 BigDAWG，它抽象了广泛的数据模型，包括关系，时间序列和流。BigDAWG 中的抽象单元称为信息孤岛。每个信息孤岛都有查询语言，数据模型并连接到一个或多个存储系统。在单个信息孤岛的范围内支持跨存储系统查询。Calcite 提供了统一的关系抽象，允许使用不同的数据模型查询后端。

Myria 是用于大数据分析的通用引擎，具有对 Python 语言的高级支持。它为其他后端引擎（如Spark和PostgreSQL）生成查询计划。

## 3. 架构

Apache Calcite 包含了许多传统数据库管理系统所具备的组件，但同时也丢弃了一些关键组件，例如数据存储、处理数据的算法以及用于存储元数据的存储库。Calcite 是有意丢弃这些组件的，这样能让 Calcite 成为衔接多数据存储以及多数据处理引擎的一种更好的选择，同时也为构建定制化的数据处理系统提供坚实的基础。

![](1)

上图展示了 Apache Calcite 架构的主要组成组件。Calcite 采用关系操作树作为其内部表示。优化引擎主要包括三个组件：规则，元数据提供程序以及计划引擎，我们将在第 6 节详细讨论这些组件。图中虚线表示与外部框架的交互，Caclcite 提供了多种方式与外部框架交互。

首先，Calcite 包含一个查询解析器和验证器，可以将 SQL 查询转换为关系操作树。由于 Calcite 不包含存储层，它提供了一种机制，可以通过适配器在外部存储引擎中定义模式 Schema 和视图(第 5 节会详细介绍)，因此 Calcite 可以在这些引擎之上使用。其次，尽管 Calcite 为需要这种数据库语言支持的系统提供了优化的 SQL 支持，但它也为已经拥有自己的语言解析和解释的系统提供了优化支持：
- 有些系统支持 SQL 查询，但是没有或者只是有限的 SQL 查询优化。例如，Hive 和 Spark 最初均提供了对 SQL 查询的支持，但是它们并没有优化器。对于这种情况，一旦查询被优化后，Calcite 就可以将关系表达式转回 SQL。这种特性使得 Calcite 能够作为独立的系统在在那些有 SQL 接口，但无优化器的数据管理系统之上运行。
- Calcite 架构不仅仅面向 SQL 查询优化。数据处理系统通常会为他们自己的查询语言选择他们自己的解析器。对于这种情况，Calcite 也能起作用。实际上，Calcite 还允许通过直接实例化关系操作来轻松地构造操作树。可以使用内置的关系表达式 Builder 接口来实现。例如，假设我们想使用表达式构建器表达以下 Apache Pig 脚本：
```
emp = LOAD 'employee_data' AS (deptno, sal);
emp_by_dept = GROUP emp by (deptno);
emp_agg = FOREACH emp_by_dept GENERATE GROUP as deptno, COUNT(emp.sal) AS c, SUM(emp.sal) as s;
dump emp_agg;
```
使用 Calcite 构建器来表示，具体如下：
```java
final RelNode node = builder.scan("employee_data")
    .aggregate(builder.groupKey("deptno"),
               builder.count(false, "c"),
               builder.sum(false, "s", builder.field("sal")))
    .build();
```
该接口展示了构建关系表达式所需的主要部分。优化阶段完成后，应用程序可以检索优化的关系表达式，然后可以将其映射回系统的查询处理单元。

## 4. 查询代数  

操作符 Operators。关系代数是 Calcite 的核心。除了表达最常见的数据操作的操作符(例如 filter、project、join 等)之外。Calcite 还包括满足不同目的的其他操作符，例如，为了能够简洁地表示复杂的操作，或更有效地识别优化时机。例如，OLAP，决策制定和流应用程序通常使用窗口定义来表示复杂的分析函数，例如一段时间或一个或多个行的数量的移动平均值。因此，Calcite 引入了一个窗口运算符，封装了窗口定义，即上限和下限，分区等，以及在每个窗口上执行的聚合函数。

特征 Traits。Calcite 不会使用不同的实体分别来表示逻辑和物理运算符。相反，会使用特征来描述与操作符相关的物理属性。这些特征有助于优化器评估不同备选方案的成本。改变属性值不会改变被评估的逻辑表达式，即，由给定运算符生成的行仍然会相同。  

在优化过程中，Calcite 会试图强制执行关系表达式上的某些特征，例如，指定列的排序顺序。关系操作符可以实现一个转换 converter 接口来指定如何转换表达式的特征。Calcite 包含了用来描述由关系表达式产生数据的物理特性的公共特征，例如排序、分组和分区。与 SCOPE 优化器类似，Calcite 优化器也可以推断这些属性，并利用它们避免不必要操作的计划。例如，如果排序操作符的输入已经正确排序(可能是因为这与后端系统中用于行的顺序相同)，则可以删除排序操作。

除了这些性质外，Calcite 的一个主要特点是即调用约定（calling convention）。本质上，特质表示表达式执行的数据处理系统。将调用约定当作特质，可以使 Calcite 能够保持透明的优化查询，对于跨引擎执行而言，该约定被看作是其他物理属性。

![](2)

例如，考虑将存储在 MySQL 的 Products 表与存储在 Splunk 中的 Orders 表，如上图所示。首先，Orders 表的扫描发生在 Splunk 中，而 Products 表的扫描发生在位 jdbc-MySQL 中。这些表必须在各自的引擎中进行扫描。连接 JOIN 在逻辑约定中，这意味着关联操作在逻辑上没有选择具体的执行引擎。此外，上图中的 SQL 查询包含一个 filter(where子句)，通过适配器特定的规则(参见第5节)被下推到 Splunk。一种可能的实现是使用 Apache Spark 作为外部引擎：将关联 JOIN 操作转换到在 Spark 中实现，同时也将 MySQL 和 Splunk 的输入也转换至 Spark 中实现。还有一种更有效的实现：Splunk 可以通过 ODBC 实现对 MySQL 的查找，如此就可以实现整个操作在 Splunk 引擎中执行。

## 5. 适配器

Calcite 中的适配器是一种架构模式，定义了 Calcite 如何合并各种数据源以进行一般访问。下图描述了它的主要组件。本质上，适配器由模型 Model、模式 Schema 以及模式工厂组成。模型 Model 是被访问数据源的物理属性规范。模式 Schema 是模型中数据的定义，包括数据格式和布局。数据本身则是通过物理表进行访问的。Calcite 在适配器中定义的表接口用来读取数据并作为查询来执行。适配器会定义一组规则添加到计划器中。例如，通常会包括将各种类型的逻辑关系表达式转换为适配器约定的相应关系表达式的规则。模式工厂组件从模型 Model 中获取元数据信息并生成模式 Schema。

如第 4 节讨论的那样，Calcite 使用一种称为调用约定的物理特征来标识关系操作符并与指定的数据库后端对应。这些物理操作符为每个适配器中底层表提供了访问路径。在解析查询并将其转换为关系代数表达式时，将为每个表创建一个操作符来表示对该表上数据进行扫描。它是适配器必须实现的最小接口。如果适配器实现了表扫描操作符，那么 Calcite 优化器就能够使用客户端操作符(sorting、filtering、joins)对这些表执行任意 SQL 查询。

这个表扫描操作符包含了适配器向后端数据库发出扫描所需的必要信息。为了扩展适配器的功能，Calcite 定义了一个可枚举调用约定。具有可枚举调用约定的关系操作符通过迭代器接口简单地操作元组。这种调用约定允许 Calcite 在适配器中实现后端可能不可用的操作符，即定制自己的操作符。例如，枚举关联（EnumverableJoin）操作符通过收集其子节点的行数据，然后在指定的属性上进行关联。

如果查询只涉及表中一小部分数据，Calcite 枚举所有元组的效率就会很低。对此种情况，可以使用基于规则的优化器来实现对指定的适配器进行优化的规则。例如，假设查询只涉及对表进行过滤和排序。在后端执行过滤的适配器可以实现与 `LogicalFilter` 匹配的规则，并将其转换为适配器的调用约定。该规则将 LogicalFilter 转换为另一个 Filter 实例。这个新的 Filter 节点具有较低的关联成本，允许 Calcite 跨适配器优化查询。

适配器的使用是一种强大的抽象，它不仅可以优化特定后端查询，还可以跨多个后端查询。通过将所有可能的逻辑下推到每个后端，然后对结果数据执行 JOIN 和聚合，Calcite 能够回答涉及多个后端表的查询。实现适配器可以像提供表扫描操作符一样简单，也可以涉及许多高级优化的设计。关系代数中表示的任何表达式都可以通过优化器规则下推到适配器。





原文：[Apache Calcite: A Foundational Framework for Optimized Query Processing Over Heterogeneous Data Sources](https://arxiv.org/pdf/1802.10233.pdf)
