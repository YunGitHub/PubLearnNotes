---
layout: post
author: smartsi
title: 深入理解Presto架构
date: 2021-01-23 16:29:01
tags:
  - Presto

categories: Presto
permalink: deep-into-presto-architecture
---

前边的文章，我们简单介绍了[为什么要使用Presto](http://smartsi.club/introducing-presto.html)，[初步安装了Presto](http://smartsi.club/how-install-and-startup-presto.html)。现在我们开始讨论 Presto 的架构。我们深入了解相关的概念，以使你能够了解更多 Presto 的查询执行模型、查询方案规划、基于代价的优化器。

在本文章中，我们首先讨论 Presto 高层次的架构组件。全面了解 Presto 的工作方式这非常重要，尤其是你准备自己安装和维护 Presto 的集群。在本文章的后边部分，当我们探讨 Presto 的查询执行模型时，我们会更加深入了解那些组件。假如你需要诊断和调优慢查询，或者你准备向 Presto 开源项目贡献代码时，了解这些是非常重要的。

## 1. Coordinator和Worker

一般我们第一次安装 Presto 时，只会使用一台机器来运行所有的组件。为了获得所需的可伸缩性和性能，只部署一台是远远不够的。

Presto 是一个分布式SQL查询引擎，类似于大规模并行处理（MPP）样式的数据库和查询引擎。Presto 不仅仅可以实现服务器的垂直扩展，也可以以水平扩展的方式把所有处理分发到服务器集群上。这意味着你可以通过添加更多节点来获得更大的处理能力。

利用这种架构，Presto 查询引擎能够跨机器集群或节点并行处理大规模的 SQL 查询。Presto 在每个节点上都是单进程的服务。运行 Presto 的多个节点（配置为彼此协作）组成一个 Presto 集群。

下图展示了由一个 Coordinator 和多个 Worker 节点组成的 Presto 集群。Presto 用户通过客户端连接到 Coordinator，例如，使用 JDBC 驱动程序或 Presto CLI。然后，Coordinator 与 Worker 节点协作，Worker 节点来访问数据源。

![](1)

Coordinator 专门用来处理用户的查询请求以及管理 Worker 节点以执行查询。Worker 节点则负责执行任务和处理数据。Discovery 服务通常运行在 Coordinator 节点上，可以让 Worker 节点注册添加到集群上。客户端、Coordinator，Worker 节点之间的所有通信以及数据传输都是基于 REST 的 HTTP/HTTPS 协议交互。

下图展示了集群内 Coordinator 和 Worker 之间以及 Worker 和 Worker 之间是如何通信的。Coordinator 与多个 Worker 通信，用于分配任务，更新状态以及获得最终的结果集返回给用户。Worker 之间可以相互通信，从运行在其他 Worker 节点的上游任务获取数据。所有 Worker 都可以从数据源读取数据。

![](2)

## 2. Coordinator

Coordinator 主要负责接收 Presto 用户的 SQL 语句，并解析这些 SQL 语句，然后生成查询计划以及管理 Worker 节点。Coordinator 是 Presto 集群的大脑，并且负责与客户端交互。用户可以通过 Presto CLI、使用 JDBC，ODBC 驱动的应用程序以及其他不同语言的客户端库与 Coordinator 进行交互。Coordinator 从客户端接收 SQL 语句才能进行计算，例如 select 语句。

每个 Presto 集群必须有一个 Coordinator，至少一个 Worker。在开发和测试环境中，一个 Presto 进程可以同时配置成这两种角色。Coordinator 追踪每个 Worker 的活跃状态，并且配合查询的执行。Coordinator 会为查询创建一个包含多个 Stage 的逻辑模型。下图展示了客户端、Coordinator 以及 Worker 之间的通信。

![](3)

收到 SQL 语句后，Coordinator 就会负责解析、分析、生成查询计划以及在不同 Worker 节点上调度查询的执行。SQL 语句会被翻译为一系列相关联的 Task，并运行在不同 Worker 节点上。Worker 一边处理数据，Coordinator 一边拉取结果，放在输出缓冲区并展示给客户端。一旦客户端读完输出缓冲区中的数据，Coordinator 便代表客户端向 Worker 请求更多的数据。反过来，Worker 与数据源交互以从中获取数据。因此，客户端连续请求数据，并由 Worker 从数据源提供数据，直到查询执行完成。Coordinator 通过基于 HTTP 的协议与 Worker 和客户端进行通信。

## 3. Discovery Service（发现服务）

Presto 使用发现服务来查找集群中的所有节点。每个 Presto 实例在启动时都会向发现服务注册，并定期发送心跳信号。这可以让 Coordinator 获得最新的可用 Worker 节点列表，并且使用这个列表来调度查询的执行。如果一个 Worker 没有发送心跳信号，发现服务触发故障检测，这一个 Worker 就不会调度到新的任务了。为了简化部署，避免运行额外的服务，Coordinator 通常会运行一个嵌入式的发现服务。会与 Presto 共享一个 HTTP 服务，并使用同一个端口。发现服务 Worker 节点上的配置，通常指向 Coordinator 的主机名称与端口。

## 4. Workers

Presto 的 Worker 是 Presto 集群中的一个服务。它负责运行 Coordinator 分配给它的任务以及数据的处理。Worker 节点通过 Connectors 向数据源获取数据，并且相互之间可以交换中间数据。最终结果会传递给 Coordinator。Coordinator 负责从 Worker 中获取最终结果，并传递给客户端。

在安装过程中，要把发现服务的主机名或IP地址告诉 Worker。当 Worker 启动后，会向发现服务广播自己，之后 Coordinator 才能为其分配任务。Worker 与其他 Worker 以及与 Coordinator 之间的通信都采用基于 HTTP 的协议。

下图显示了多个 Worker 如何从数据源获取数据，并协作处理数据，直到有一个 Worker 把数据提供给了 Coordinator。

![](4)

## 5. 基于Connector的架构

Presto 中存储与计算分离的核心是基于 Connector 的架构。Connector 为 Presto 提供了一个可以访问任意数据源的接口。

每个 Connector 为底层的数据源提供了一层基于表的抽象接口。只要数据能够表示为表、列、行，并且可以使用 Presto 支持的数据类型，那么就可以创建一个 Connector，查询引擎就可以通过这个 Connector 处理数据。

Presto 提供了一套 SPI 接口，可以使用它们来实现 Connector。通过实现 SPI 接口，Presto 就可以在内部使用标准的操作连接任何数据源，并且在数据源上执行任何操作。Connector 负责和数据源交互的细节。

每个 Connector 都要实现 API 的三个部分：
- 读取 table/view/schema 元数据的操作。
- 提供逻辑上的数据分区，这样 Presto 就可以并行读写。
- 用于将源数据转换为查询引擎期望的内存格式的数据源（Data Source）以及将内存格式转换为源数据的Sink。

Presto 为很多系统都提供了 Connector，例如，HDFS/Hive、MySQL、PostgreSQL、MS SQL Server、Kafka、Cassandra、Redis等等。

另外，Presto 的 SPI 接口还可以为我们提供创建自定义 Connector 的能力。这在你访问的数据源没有兼容的 Connector 场景下是非常重要的。如果您的企业中有专有的数据源（非开源），这就可能需要自定义 Connector。这就是 Presto 用户可以使用 SQL 来查询任何数据源的真正原因了。

下图展示了 Presto SPI 为 Coordinator 使用的元数据，数据统计，数据位置 以及 Worker 使用的数据流提供的不同接口。

![](5)

Presto Connector 是每个服务在启动时都要加载的插件。可以通过 catalog 属性文件中特定参数进行配置，并且会从 plugin 目录加载。

## 6. Catalogs, Schemas, 以及 Tables

Presto 集群使用前面描述的基于 Connector 的架构来处理所有查询。每个 catalog 配置都会使用一个 Connector 来访问指定的数据源。数据源在 catalog 中展示一个或多个 schemas。每个 schema 包含若干个 table，table 中的每一行就是多列数据，每一列是不同的类型。






原文:[Presto: The Definitive Guide](https://learning.oreilly.com/library/view/presto-the-definitive/9781492044260/ch01.html#chapter-introduction)
