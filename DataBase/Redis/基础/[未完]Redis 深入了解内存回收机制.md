

Redis 的内存回收机制主要体现在以下两个方面：
- 删除到达过期时间的键对象。
- 内存使用达到 maxmemory 上限时触发内存溢出控制策略。

## 1. 删除过期键

Redis 所有的键都可以设置过期属性，内部保存在过期字典中。由于进程内保存大量的键，维护每个键精准的过期删除机制会导致消耗大量的CPU，对于单线程的 Redis 来说成本过高，因此 Redis 采用惰性删除和定时任务删除机制实现过期键的内存回收。

### 1.1 惰性删除

惰性删除用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略是出于节省 CPU 成本考虑，不需要单独维护 TTL 链表来处理过期键的删除。但是单独用这种方式存在内存泄露的问题，当过期键一直没有访问将无法得到及时删除，从而导致内存不能及时释放。正因为如此，Redis 还提供另一种定时任务删除机制作为惰性删除的补充。

### 1.2 定时任务删除

Redis 内部维护一个定时任务，默认每秒运行 10次（通过配置 hz 控制）。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例、使用快慢两种速率模式回收键，

![](1)

流程说明：
- 定时任务在每个数据库空间随机检查 20 个键，当发现过期时删除对应的键。
- 如果超过检查数 25% 的键过期，循环执行回收逻辑直到不足 25% 或运行超时为止，慢模式下超时时间为 25 毫秒。
- 如果之前回收键逻辑超时，则在Redis触发内部事件之前再次以快模式运行回收过期键任务，快模式下超时时间为1毫秒且2秒内只能运行1次。
- 快慢两种模式内部删除逻辑相同，只是执行的超时时间不同。

## 2. 内存溢出控制策略

当 Redis 所用内存达到 maxmemory 上限时会触发相应的溢出控制策略。具体策略受 maxmemory-policy 参数控制，Redis 支持 6 种策略，如下所示：
- noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息（error）OOM command not allowed when used memory，此时 Redis 只响应读操作。
- volatile-lru：根据 LRU 算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到 noeviction 策略。
- allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
- allkeys-random：随机删除所有键，直到腾出足够空间为止。
- volatile-random：随机删除过期键，直到腾出足够空间为止。
- volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。

内存溢出控制策略可以采用 config set maxmemory-policy{policy} 动态配置。Redis 支持丰富的内存溢出应对策略，可以根据实际需求灵活定制，比如当设置 volatile-lru 策略时，保证具有过期属性的键可以根据 LRU 剔除，而未设置超时的键可以永久保留。还可以采用 allkeys-lru 策略把 Redis 变为纯缓存服务器使用。当 Redis 因为内存溢出删除键时，可以通过执行 info stats 命令查看 evicted_keys 指标找出当前 Redis 服务器已剔除的键数量。
每次 Redis 执行命令时如果设置了 maxmemory 参数，都会尝试执行回收内存操作。当 Redis 一直工作在内存溢出（used_memory>maxmemory）的状态下且设置非 noeviction 策略时，会频繁地触发回收内存的操作，影响 Redis 服务器的性能。
