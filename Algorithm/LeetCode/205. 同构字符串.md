## 1. 题目

[205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

## 2. 思路

需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。需要注意的是在 s 和 t 中同一个字符的映射关系可能是不一样的，例如示例 3 中，s 中的 e 字符映射为 l 字符，但是 t 中的 e 字符却映射了 r 字符。所以需要两个哈希表来维护 s 和 t 中的映射关系。第一张哈希表 sMap 以 s 中字符为键，映射至 t 的字符为值，第二张哈希表 tMap 以 t 中字符为键，映射至 s 的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突（即当前下标 index 对应的字符 s[index] 已经存在映射且不为 t[index] 或当前下标 index 对应的字符 t[index] 已经存在映射且不为 s[index]）时说明两个字符串无法构成同构，返回 false。

## 3. 代码

```java
public boolean isIsomorphic(String s, String t) {
    int sLen = s.length();
    int tLen = t.length();
    if (sLen != tLen) {
        return false;
    }
    Map<Character, Character> sMap = new HashMap<>();
    Map<Character, Character> tMap = new HashMap<>();
    for (int i = 0;i < sLen;i++) {
        Character sc = s.charAt(i);
        Character tc = t.charAt(i);
        // (1) 两个字符相同 直接跳过
        if (sc == tc) {
            continue;
        }
        // (2) 不同字符的映射
        if (sMap.containsKey(sc) && sMap.get(sc) != tc) {
            return false;
        }
        if (tMap.containsKey(tc) && tMap.get(tc) != sc) {
            return false;
        }
        sMap.put(sc, tc);
        tMap.put(tc, sc);
    }
    return true;
}
```
