
## 2. 思路1-栈

这道题目与 [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/solution/) 比较类似，难点在于本题目中链表中数位的顺序与我们做加法的顺序是相反的。为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。

> 对于逆序处理应该首先想到栈。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    Stack<Integer> s1 = new Stack<>();
    Stack<Integer> s2 = new Stack<>();
    // 压栈
    ListNode curNode1 = l1;
    ListNode curNode2 = l2;
    while(curNode1 != null){
        s1.add(curNode1.val);
        curNode1 = curNode1.next;
    }
    while(curNode2 != null){
        s2.add(curNode2.val);
        curNode2 = curNode2.next;
    }

    // 哨兵
    ListNode dummy = new ListNode(0);
    int c = 0;
    while(!s1.isEmpty() || !s2.isEmpty() || c!= 0){
        int num1 = !s1.isEmpty() ? s1.pop() : 0;
        int num2 = !s2.isEmpty() ? s2.pop() : 0;
        int sum = num1 + num2 + c;
        c = sum / 10;
        // 链表头插入法
        ListNode newNode = new ListNode(sum % 10);
        newNode.next = dummy.next;
        dummy.next = newNode;
    }
    return dummy.next;
}
```

## 3. 思路2-反转链表

```java
public ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
    // 反转链表
    ListNode r1 = reverseList(l1);
    ListNode r2 = reverseList(l2);
    // 两数相加
    ListNode dummy = new ListNode(0);
    int carry = 0;
    while (r1 != null || r2 != null || carry != 0) {
        int v1 = r1 != null ? r1.val : 0;
        int v2 = r2 != null ? r2.val : 0;
        int sum = v1 + v2 + carry;
        // 进位
        carry = sum / 10;
        // 头插入法
        ListNode newNode = new ListNode(sum % 10);
        newNode.next = dummy.next;
        dummy.next = newNode;
        // 继续遍历
        if (r1 != null) {
            r1 = r1.next;
        }
        if (r2 != null) {
            r2 = r2.next;
        }
    }
    return dummy.next;
}

// 反转链表
public ListNode reverseList(ListNode head) {
    // 哨兵
    ListNode dummy = new ListNode(0);
    // 当前节点
    ListNode node = head;
    // 下一个节点
    ListNode nextNode;
    while(node != null){
        // 保存下一个节点的
        nextNode = node.next;
        // 插入节点到dummy节点后
        node.next = dummy.next;
        dummy.next = node;
        // 更新当前节点
        node = nextNode;
    }
    return dummy.next;
}
```
