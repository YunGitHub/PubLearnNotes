
## 2. 思路-递归

叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点
当 root 节点左右孩子都为空时，返回 1
当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值

```java
// 递归实现 深度优先遍历
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 左子树的最小深度
    int leftMinDepth = minDepth(root.left);
    // 右子树的最小深度
    int rightMinDepth = minDepth(root.right);

    // 只有左子树 当前节点的最小深度=右子树最小深度+1
    if (rightMinDepth == 0 && leftMinDepth != 0) {
        return leftMinDepth + 1;
    }
    // 只有右子树 当前节点的最小深度=左子树最小深度+1
    if (leftMinDepth == 0 && rightMinDepth != 0) {
        return rightMinDepth + 1;
    }
    // 左右子树均有或者均没有 当前节点的最小深度=左右子树的最小深度 + 1
    int minDepth = Math.min(leftMinDepth, rightMinDepth) + 1;
    return minDepth;
}
```

## 3. 思路-层次遍历

同样，我们可以想到使用广度优先搜索的方法，遍历整棵树。当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    int minDepth = 0;
    while (!queue.isEmpty()) {
        minDepth ++;
        // 当前层节点个数
        int levelSize = queue.size();
        // 遍历当前层节点
        for (int index = 0;index < levelSize;index ++) {
            TreeNode node = queue.remove();
            // 找到一个最近叶子节点
            if (node.left == null && node.right == null) {
                return minDepth;
            }
            // 下一层节点加入队列
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }
    return minDepth;
}
```
