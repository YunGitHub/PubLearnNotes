## 1. 题目

[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

## 2. 思路

我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，如果此时路径和恰为目标和时，我们就找到了一条满足条件的路径。可以采用二叉树前序遍历递归实现类似的思路，到叶子节点的时候判断路径和是否满足目标值：
```java
// 如果是叶子节点并且SUM等于指定值则为要寻找的一条路径
if (node.left == null && node.right == null && sum == 0) {
    paths.add(new ArrayList<>(path));
    //return;
}
```
需要注意的是不用 return，不然在回溯到上一层时叶子节点没办法从 path 中删除。

## 3. 实现

```java
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> paths = new ArrayList<>();
    if (root == null) {
        return paths;
    }
    // 深度遍历
    dfs(root, new ArrayList<>(), paths, targetSum);
    return paths;
}

private void dfs(TreeNode node, List<Integer> path, List<List<Integer>> paths, int sum) {
    // 终止条件
    if (node == null) {
        return;
    }
    path.add(node.val);
    sum -= node.val;
    // 如果是叶子节点并且SUM等于指定值则为要寻找的一条路径
    if (node.left == null && node.right == null && sum == 0) {
        paths.add(new ArrayList<>(path));
        // 不要 return 不然叶子节点没办法从 path 删除
        //return;
    }
    // 遍历左节点
    dfs(node.left, path, paths, sum);
    // 遍历右节点
    dfs(node.right, path, paths, sum);
    // 回溯上层节点删除当前节点
    path.remove(path.size()-1);
}
```
