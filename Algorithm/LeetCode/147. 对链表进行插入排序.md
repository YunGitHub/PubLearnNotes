
## 2. 思路

插入排序的基本思想是，维护一个有序序列，初始时有序序列只有一个元素，每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。如果是数组的插入排序，则数组的前面部分是有序序列，每次找到有序序列后面的第一个元素（待插入元素）的插入位置，将有序序列中的插入位置后面的元素都往后移动一位，然后将待插入元素置于插入位置。对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的时间复杂度是 O(1)，但是找到插入位置需要遍历链表中的节点，时间复杂度是 O(n)，因此链表插入排序的总时间复杂度仍然是 O(n^2)，其中 n 是链表的长度。

对于单向链表而言，只有指向后一个节点的指针，因此需要从链表的头节点开始往后遍历链表中的节点，寻找插入位置。对链表进行插入排序的具体过程如下：
- 首先判断给定的链表是否为空，若为空，则不需要进行排序，直接返回。
- 创建哑节点 dummy，令 dummy.next = head。引入哑节点是为了便于在 head 节点之前插入节点。
- 寻找第一个不满足排序的元素，cur 指向不满足排序的节点，pre 为前一节点，由于第一个节点满足排序要求，所以初始化时 pre = head，cur = head.next
- 比较 pre 和 cur 的节点值。若 pre.val <= cur.val，说明 cur 应该位于 pre 之后，将 pre 和 cur 后移一位
- 否则，从链表的头节点开始往后遍历链表中的节点，寻找插入 cur 的位置
- 令 insertPre 为插入 cur 的位置的前一个节点，初始化时 insertPre = dummy，insertCur = dummy.next。
  - 从链表中删除 cur 节点：pre.next = cur.next;
  - 插入 cur 节点到插入位置：cur.next = insertPre.next，insertPre.next = cur;
  - 更新 cur 节点 cur = pre.next
- 返回 dummyHead.next，为排序后的链表的头节点。

```java
public ListNode insertionSortList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode pre = head;
    ListNode cur = head.next;
    while (cur != null) {
        if (pre.val <= cur.val) {
            // 有序 继续推进
            pre = cur;
            cur = cur.next;
        } else {
            // 出现一个无序元素 寻找正确的插入位置
            ListNode insertPre = dummy;
            ListNode insertCur = dummy.next;
            while (insertCur.val <= cur.val) {
                insertPre = insertCur;
                insertCur = insertCur.next;
            }
            // insertPre 的下一个位置即为插入位置
            // 删除 cur 节点
            pre.next = cur.next;
            // 插入 cur 节点
            cur.next = insertPre.next;
            insertPre.next = cur;
            // 更新 cur 节点
            cur = pre.next;
        }
    }
    return dummy.next;
}
```
