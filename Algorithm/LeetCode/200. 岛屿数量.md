
## 2. 思想

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 2（表示已经遍历过）。最终岛屿的数量就是我们进行深度优先搜索的次数。

> 具体参考：[算法系列 岛屿类回溯问题](https://github.com/sjf0115/PubLearnNotes/blob/master/Algorithm/Summary/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%975%20%E5%B2%9B%E5%B1%BF%E7%B1%BB%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98.md)

```java
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    int r = grid.length;
    int c = grid[0].length;
    int islands = 0;
    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            // 找到一块为遍历过的岛屿则加1
            if (grid[i][j] == '1') {
                ++islands;
                dfs(grid, i, j);
            }
        }
    }
    return islands;
}

// 深度优先遍历
void dfs(char[][] grid, int r, int c) {
    // 1. 终止条件
    // 如果超出网格直接返回
    if (!isInGrid(grid, r, c)) {
        return;
    }
    // 如果已经走过或者是海洋直接返回
    if (grid[r][c] != '1') {
        return;
    }
    // 2. 标记为已遍走过
    grid[r][c] = '2';

    // 3. 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean isInGrid(char[][] grid, int r, int c) {
    return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
}
```
