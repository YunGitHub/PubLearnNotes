## 1. 题目

[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

## 2. 思路

我们首先想到的解法是穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。

我们采用先序遍历二叉树上每个节点 node，然后计算出以 node 节点为根节点的路径个数，然后对这些路径数目求和即为返回结果：
```java
// 先序遍历每个节点 作为根节点计算路径和条数
public int preOrder(TreeNode node, int targetSum) {
    if (node == null) {
        return 0;
    }
    int num = pathSumNum(node, targetSum);
    int leftNum = preOrder(node.left, targetSum); // 左
    int rightNum = preOrder(node.right, targetSum); // 右
    return num + leftNum + rightNum;
}
```
那如何计算以 node 节点为根节点满足的路径个数呢？我们定义 pathSumNum(TreeNode node, long targetSum) 递归函数来计算以 node 节点为开始节点的路径中满足路径和为 targetSum 的路径个数：
```java
// 计算以 node 节点为开始节点的路径中满足路径和为 targetSum 的路径个数
public int pathSumNum(TreeNode node, long targetSum) {
    // 路径个数
    int num = 0;
    // 终止条件
    if (node == null) {
        return 0;
    }
    // 找到一条路径满足
    if (targetSum - node.val == 0) {
        num += 1;
    }
    // 左子树中路径个数
    int leftNum = pathSumNum(node.left, targetSum - node.val);
    // 右子树中路径个数
    int rightNum = pathSumNum(node.right, targetSum - node.val);
    // 当前节点子树中路径个数 = 截止到当前路径中满足个数 + 左子树中满足个数 + 右子树中满足个数
    return leftNum + rightNum + num;
}
```

## 3. 实现

```java
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return 0;
    }
    return preOrder(root, targetSum);
}

// 先序遍历每个节点 作为根节点计算路径和条数
public int preOrder(TreeNode node, int targetSum) {
    if (node == null) {
        return 0;
    }
    int num = pathSumNum(node, targetSum);
    int leftNum = preOrder(node.left, targetSum); // 左
    int rightNum = preOrder(node.right, targetSum); // 右
    return num + leftNum + rightNum;
}

// 计算以 node 节点为开始节点的路径中满足路径和为 targetSum 的路径个数
public int pathSumNum(TreeNode node, long targetSum) {
    // 路径个数
    int num = 0;
    // 终止条件
    if (node == null) {
        return 0;
    }
    // 找到一条路径满足
    if (targetSum - node.val == 0) {
        num += 1;
    }
    // 左子树中路径个数
    int leftNum = pathSumNum(node.left, targetSum - node.val);
    // 右子树中路径个数
    int rightNum = pathSumNum(node.right, targetSum - node.val);
    // 当前节点子树中路径个数 = 截止到当前路径中满足个数 + 左子树中满足个数 + 右子树中满足个数
    return leftNum + rightNum + num;
}
```
