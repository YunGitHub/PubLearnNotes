## 1. 题目

[154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

## 2. 思路

在二分查找的每一步中，左边界为 left，右边界为 right，区间的中点为 mid，最小值就在该区间内。我们将中轴元素 `nums[mid]` 与左边界元素 `nums[left]` 进行比较，可能会有以下的三种情况：
- 第一种情况是 `nums[left] < nums[mid]`，即中间元素大于区间最左边元素。这说明 `nums[mid]` 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。
- 第一种情况是 `nums[left] > nums[mid]`，即中间元素小于区间最左边元素。这说明 `nums[mid]` 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。
- 第三种情况是 `num[left] == nums[mid]`。由于重复元素的存在，我们并不能确定 `nums[mid]` 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于左边元素和中间元素的值相同，所以就算 `nums[left]` 是最小值，我们可以忽略二分查找区间的左边元素。

## 3. 实现

```java
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        // 单调递增数组 最小值为left元素
        if (nums[left] < nums[right]) {
            return nums[left];
        }
        // 旋转数组
        int mid = (right - left) / 2 + left;
        if (nums[left] < nums[mid]) {
            // [left, mid] 有序 最小值出现在 [mid+1, right]
            left = mid + 1;
        } else if (nums[left] > nums[mid]) {
            // [mid+1, right] 有序 最小值出现在 [left, mid]
            right = mid;
        } else {
            left += 1;
        }
    }
    return nums[right];
}
```
