
## 2. 思路-计算链表长度

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是我们需要删除的节点。

![](https://assets.leetcode-cn.com/solution-static/19/p1.png)

为了与题目中的 n 保持一致，节点的编号从 1 开始，头节点为编号 1 的节点。为了方便删除操作，我们可以从哑节点开始遍历 `L−n` 个节点(不包括哑节点)。当遍历到第 `L−n` 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // 计算链表长度
    ListNode node = head;
    int size = 0;
    while(node != null){
        size++;
        node = node.next;
    }
    // 删除第size-n+1个元素
    node = dummy;
    int index = 0;
    while (index < size-n){
        node = node.next;
        index++;
    }
    // 删除node.next
    node.next = node.next.next;
    return dummy.next;
}
```

## 3. 思路-双指针

我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。

由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 second 比 first 超前 n 个节点。当 second 遍历到链表的末尾时，first 就恰好处于倒数第 n 个节点。

具体地，初始时 first 和 second 均指向头节点。我们首先使用 second 对链表进行遍历，遍历的次数为 n。此时，first 和 second 之间间隔了 n-1 个节点，即 second 比 first 超前了 n 个节点。在这之后，我们同时使用 first 和 second 对链表进行遍历。当 second 遍历到链表的末尾（即 second 为空指针）时，first 恰好指向倒数第 n 个节点。

![](https://assets.leetcode-cn.com/solution-static/19/p3.png)

我们可以考虑在初始时将 first 指向哑节点，其余的操作步骤不变。这样一来，当 second 遍历到链表的末尾时，first 的下一个节点就是我们需要删除的节点。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode first = dummy;
    ListNode second = dummy;
    // second 先前行 n 步
    int index = 0;
    while(index <= n){
        second = second.next;
        index++;
    }
    // first 与 second 一起前行 second 移至末尾
    while(second != null){
        first = first.next;
        second = second.next;
    }
    // 删除first.next
    first.next = first.next.next;
    return dummy.next;
}
```
