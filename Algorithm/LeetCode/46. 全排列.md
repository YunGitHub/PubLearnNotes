
### 1. 题目

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:
```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### 2. 思路

每一次都从列表中选择一个数加入列表中。每次都是从列表中第一个开始选择，如果之前使用过则跳过。

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    if(nums == null || nums.length == 0){
        return res;
    }
    List<Integer> tmpList = new ArrayList<>();
    boolean[] visited = new boolean[nums.length];
    backtrack(nums, tmpList, res, visited);
    return res;
}

// 回溯 每一轮搜索选择一个未使用过数加入列表中
private void backtrack(int[] nums, List<Integer> tmpList, List<List<Integer>> res, boolean[] visited) {
    // 1. 终止条件 找到一种排列
    if (tmpList.size() == nums.length) {
        res.add(new ArrayList<>(tmpList));
        return;
    }
    for (int i = 0;i < nums.length;i++) {
        // 判断是否使用过
        if (visited[i]){
            continue;
        }
        tmpList.add(nums[i]);
        visited[i] = true;
        // 2. 递归函数
        backtrack(nums, tmpList, res, visited);
        // 回溯
        visited[i] = false;
        tmpList.remove(tmpList.size()-1);
    }
}
```

上述代码在判断是否访问过时使用的是 visited 数组来判断，因为输入数组中不包含重复元素，所以也可以直接通过临时变量 tmpList 来判断是否已经访问过：
```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    if(nums == null || nums.length == 0){
        return res;
    }
    List<Integer> tmpList = new ArrayList<>();
    backtrack(nums, tmpList, res);
    return res;
}

// 回溯 每一轮搜索选择一个未使用过数加入列表中
private void backtrack(int[] nums, List<Integer> tmpList, List<List<Integer>> res) {
    // 1. 终止条件 找到一种排列
    if (tmpList.size() == nums.length) {
        res.add(new ArrayList<>(tmpList));
        return;
    }
    for (int i = 0;i < nums.length;i++) {
        // 判断是否使用过
        if (tmpList.contains(nums[i])){
            continue;
        }
        tmpList.add(nums[i]);
        // 2. 递归函数
        backtrack(nums, tmpList, res);
        // 回溯
        tmpList.remove(tmpList.size()-1);
    }
}
```
