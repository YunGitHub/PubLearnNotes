
## 2. 思路

我们从根节点开始遍历；如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树，因此遍历它的左子节点；如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树，因此遍历它的右子节点；如果当前节点的值不满足上述两条要求，那么说明当前节点就是公共祖先。

迭代实现：
```java
private TreeNode helper2(TreeNode root, TreeNode p, TreeNode q) {
    while (root != null) {
        if (root.val > p.val && root.val > q.val) {
            // root 均大于 q 和 q 公共祖先在左子树中
            root = root.left;
        } else if (root.val < p.val && root.val < q.val) {
            // root 均小于 q 和 q 公共祖先在右子树中
            root = root.right;
        } else {
            // p 和 q 在 root 两侧
            // p 或者 q 之一等于 root
            // root 为公共祖先
            return root;
        }
    }
    return null;
}
```

递归实现：
```java
private TreeNode helper(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return root;
    }
    if (root.val > p.val && root.val > q.val) {
        // root 均大于 q 和 q 公共祖先在左子树中
        return helper(root.left, p, q);
    } else if (root.val < p.val && root.val < q.val) {
        // root 均小于 q 和 q 公共祖先在右子树中
        return helper(root.right, p, q);
    } else {
        // p 和 q 在 root 两侧
        // p 或者 q 之一等于 root
        // root 为公共祖先
        return root;
    }
}
```
