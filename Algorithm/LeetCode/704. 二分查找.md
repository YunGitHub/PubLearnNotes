
## 2. 思路

如果排序数组 nums 中包含目标数字 target，那么返回 target 在数组中的下标，否则返回 -1。二分查找的做法是在下标为 left 和 right 之间的子数组 `[left, right]` 中查找。left 是查找范围子数组最左边的下标，初始化为 0，right 是查找范围子数组最右边的下标，初始化为数组的最后一个下标，因此最初的查找范围为整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半：
- 如果中间数字刚好等于目标数字 target，那么可以返回中间数字的下标 mid。
- 如果中间数字大于目标数字，那么只需要在当前查找范围的前半部分查找。将 right 指向当前中间数字的前一个数字，即下标为 mid-1 的位置，下一轮查找范围(还是下标从 left 到 right 的子数组)就是当前查找范围的前半部分。
- 如果中间数字小于目标数字的情形则刚好相反，只需要在当前查找范围的后半部分查找。将 left 指向当前中间数字的下一个数字，即下标为 mid+1 的位置，下一轮查找范围(还是下标从 left 到 right 的子数组)就是当前查找范围的后半部分。

二分查找的条件是查找范围不为空，即 left ≤ right。当 left 等于 right 时，查找范围是长度为 1 的子数组。长度为 1 的子数组仍然是一个有效的查找范围，但当 left 大于 right 时这两个下标就不能形成一个有效的查找返回，因此 while 循环的条件是 left 小于或等于 right。

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    // 在区间 [left, right] 中查找
    while (left <= right){
        // int mid = (left + right) / 2;
        // 计算中间点 防止溢出
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        if (num == target){
            // 如果中间数字等于目标数字 target 直接返回下标 mid
            return mid;
        } else if (num > target) {
            // 如果中间数字大于目标数字，那么只需要在当前查找范围的前半部分查找
            // 将 right 指向当前中间数字的前一个数字
            right = mid - 1;
        } else {
            // 如果中间数字小于目标数字，那么只需要在当前查找范围的后半部分查找
            // 将 left 指向当前中间数字的下一个数字
            left = mid + 1;
        }
    }
    return -1;
}
```
