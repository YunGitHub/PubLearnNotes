## 1. 题目

给你一棵二叉树的根节点 root ，返回树的 最大宽度 。树的 最大宽度 是所有层中最大的 宽度 。

每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。

题目数据保证答案将会在  32 位 带符号整数范围内。

## 2. 思路-广度优先遍历

此题求二叉树所有层的最大宽度，比较直观的方法是求出每一层的宽度，然后求出最大值。求每一层的宽度时，因为两端点间的 null 节点也需要计入宽度，因此可以对节点进行编号。假设根节点从 0 开始编号，如果父节点编号为 index，那么左子节点的编号记为 2×index+1，右子节点的编号记为 2×index+2，计算每层宽度时，用每层节点的最大编号减去最小编号再加 1 即为宽度。遍历节点时，可以用广度优先搜索来遍历每一层的节点，并求出最大值。

```java
public int widthOfBinaryTree(TreeNode root) {
    // <TreeNode, Index>
    Queue<Pair<TreeNode, Integer>> queue = new ArrayDeque<>();
    queue.add(new Pair<>(root, 0));
    int maxWidth = 0;
    while(!queue.isEmpty()) {
        int size = queue.size();
        // 开始遍历当前层
        int minIndex = 0;
        int maxIndex = 0;
        for(int i = 0;i < size;i++) {
            Pair<TreeNode, Integer> pair = queue.remove();
            // 节点
            TreeNode node = pair.getKey();
            // 节点编号
            Integer index = pair.getValue();
            // 每层的第一个节点编号和最后一个节点编号
            if (i == 0) {
                minIndex = index;
            }
            if (i == size - 1) {
                maxIndex = index;
            }
            // 左子节点加入队列
            if (node.left != null) {
                queue.add(new Pair<>(node.left, 2*index+1));
            }
            // 右子节点加入队列
            if (node.right != null) {
                queue.add(new Pair<>(node.right, 2*index+2));
            }
        }
        int width = maxIndex - minIndex + 1;
        if (width > maxWidth) {
            maxWidth = width;
        }
    }
    return maxWidth;
}
```
