---
layout: post
author: sjf0115
title: 347. 前K个高频元素
date: 2018-08-23 21:00:07
tags:
  - LeetCode

categories: LeetCode
permalink: leetcode-top-k-frequent-elements
---

### 1. 题目

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

示例 1:
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```
示例 2:
```
输入: nums = [1], k = 1
输出: [1]
```
说明：
- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。

### 2. 思路

首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。最简单的做法是给「出现次数数组」排序。但由于可能有 O(N) 个不同的出现次数（其中 N 为原数组长度），故总的算法复杂度会达到 O(NlogN)，不满足题目的要求。

在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：
- 如果堆的元素个数小于 k，就可以直接插入堆中。
- 如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。

遍历完成后，堆中的元素就代表了「出现次数数组」中前 kk 大的值。


```java
public List<Integer> topKFrequent(int[] nums, int k) {
    Queue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>(k, new Comparator<Map.Entry<Integer, Integer>>() {
        @Override
        public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
            return o1.getValue() - o2.getValue();
        }
    });
    Map<Integer, Integer> countMap = new HashMap<>();
    for(int num : nums){
        if(countMap.containsKey(num)){
            countMap.put(num, countMap.get(num) + 1);
        }
        else {
            countMap.put(num, 1);
        }
    }
    for(Map.Entry entry : countMap.entrySet()){
        System.out.println(entry.getKey());
        queue.add(entry);
        if(queue.size() > k){
            queue.poll();
        }
    }
    List<Integer> result = new ArrayList();
    for(int i = 0;i < k;i++){
        Map.Entry<Integer, Integer> element = queue.poll();
        result.add(0, element.getKey());
    }
    return result;
}
```
