
## 2. 思路

我们以如下示例为例进行说明：

![](../../Image/Algorithm/reverse-linked-list-ii-1.png)

整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。

![](../../Image/Algorithm/reverse-linked-list-ii-2.png)

下面我们具体解释如何实现。使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：
- curr：永远指向待反转区域的第一个节点 left；
- next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；
- pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。

第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤：

![](../../Image/Algorithm/reverse-linked-list-ii-3.png)

操作步骤：
- 先将 curr 的下一个节点记录为 next；
- 执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；
- 执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；
- 执行操作 ③：把 pre 的下一个节点指向 next。

第 1 步完成以后「拉直」的效果如下：

![](../../Image/Algorithm/reverse-linked-list-ii-4.png)

第 2 步，同理。同样需要注意 「穿针引线」操作的先后顺序。

![](../../Image/Algorithm/reverse-linked-list-ii-5.png)

第 2 步完成以后「拉直」的效果如下：

![](../../Image/Algorithm/reverse-linked-list-ii-6.png)

第 3 步，同理。

![](../../Image/Algorithm/reverse-linked-list-ii-7.png)

第 3 步完成以后「拉直」的效果如下：

![](../../Image/Algorithm/reverse-linked-list-ii-8.png)

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummyNode = new ListNode(0);
    dummyNode.next = head;
    // pre 永远指向待反转区域的第一个节点 left 的前一个节点
    ListNode pre = dummyNode;
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }
    // cur 永远指向待反转区域的第一个节点 left
    ListNode cur = pre.next;
    // 永远指向 cur 的下一个节点，循环过程中 next 会发生变化
    ListNode next = cur.next;
    for (int i = 0; i < right - left; i++) {
        // 断开翻转节点
        cur.next = next.next;
        // 插入翻转节点
        next.next = pre.next;
        pre.next = next;
        // 更新next的位置
        next = cur.next;
    }
    return dummyNode.next;
}
```
