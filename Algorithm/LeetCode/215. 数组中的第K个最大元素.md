
## 2. 思路

我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。

```java
public int findKthLargest(int[] nums, int k) {
    int size = nums.length;
    // 最大堆的个数
    int n = size;
    // 构建 n 个元素的最大堆
    buildMaxHeap(nums, n);
    for (int i = size - 1; i >= size - k + 1; --i) {
        // 数组中最大元素在根 a[0]，通过与 a[i] 交换来达到最终的正确位置
        swap(nums, 0, i);
        --n;
        // 重新调整最大堆
        maxHeap(nums, 0, n);
    }
    return nums[0];
}

// 建堆: 将一个数组 a[0,n-1] 变成一个最大堆
public void buildMaxHeap(int[] a, int n) {
    // 从第一个非叶子节点开始调整
    for (int i = n / 2; i >= 0; --i) {
        maxHeap(a, i, n);
    }
}

// 调整堆
public void maxHeap(int[] a, int index, int n) {
    int leftIndex = index * 2 + 1;
    int rightIndex = index * 2 + 2;
    int largestIndex = index;
    // 判断左子节点是不是最大值
    if (leftIndex < n && a[leftIndex] > a[largestIndex]) {
        largestIndex = leftIndex;
    }
    // 判断右子节点是不是最大值
    if (rightIndex < n && a[rightIndex] > a[largestIndex]) {
        largestIndex = rightIndex;
    }
    // 如果 a[index] 是最大的，则以 index 为根的子树已是最大堆
    // 否则 index 的子节点有最大元素,需要交换 a[index],a[largestIndex],从而使 index 满足最大堆性质
    if (largestIndex != index) {
        swap(a, index, largestIndex);
        // 交换之后可能会破坏子树的最大堆性质 需要递归调整子树
        maxHeap(a, largestIndex, n);
    }
}

// 交换两个元素
public void swap(int[] a, int i, int j) {
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```

参考：[算法系列之一 堆排序](https://blog.csdn.net/SunnyYoona/article/details/84589087)
