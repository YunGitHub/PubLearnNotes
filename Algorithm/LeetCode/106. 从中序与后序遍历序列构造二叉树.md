
## 2. 思路

后序遍历的顺序是左子树，右子树，根节点。中序遍历的顺序是左子树，根节点，右子树。所以我们只需要根据后序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。生成左子树和右子树就可以递归的进行了。

我们具体来分析一下：
```
postorder = [9,15,7,20,3]
inorder = [9,3,15,20,7]
首先根据 postorder 找到根节点是 3（最后一个元素），然后根据根节点将 inorder 分成左子树和右子树

左子树：inorder [9]
右子树：inorder [15,20,7]

把相应的前序遍历的数组也加进来

左子树：inorder [9] postorder [9]
右子树：inorder [15,20,7] postorder [15,7,20]

现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题
然后重复上边的步骤继续划分，直到 postorder 和 inorder 都为空，返回 null 即可
```

```java
public class ConstructBinaryTreeFromInorderAndPostorderTraversal106 {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int size = postorder.length;
        if(size <= 0){
            return null;
        }
        // 后序遍历数组从末尾开始
        // 中序遍历数组从开头开始
        return prePostBuildTree(inorder, postorder, 0, size-1, size);
    }

    // postIndex 子树后序遍历开始下标
    // inIndex   子树中序遍历开始下标
    // size      子树节点个数
    private TreeNode prePostBuildTree(int[] inOrder, int[] postOrder, int inIndex, int postIndex, int size) {
        if(size <= 0){
            return null;
        }
        // 根节点
        TreeNode root = new TreeNode(postOrder[postIndex]);
        // 寻找根节点在中序遍历数组的下标
        int index = 0;
        for(int i = 0;i < size;++i){
            if(postOrder[postIndex] == inOrder[inIndex+i]){
                index = inIndex+i;
                break;
            }
        }

        // 左子树个数
        int leftSize = index - inIndex;
        // 右子树个数
        int rightSize = size - leftSize - 1;

        // 递归构建左子树 后序遍历数组倒着来
        root.left = prePostBuildTree(inOrder, postOrder, inIndex, postIndex-1-rightSize, leftSize);
        // 递归构建右子树
        root.right = prePostBuildTree(inOrder, postOrder, index+1, postIndex-1, rightSize);
        return root;
    }
}
```
