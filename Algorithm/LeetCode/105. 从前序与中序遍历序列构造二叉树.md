
## 2. 思路-递归

先序遍历的顺序是根节点，左子树，右子树。中序遍历的顺序是左子树，根节点，右子树。所以我们只需要根据先序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。生成左子树和右子树就可以递归的进行了。

我们具体来分析一下：
```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
首先根据 preorder 找到根节点是 3，然后根据根节点将 inorder 分成左子树和右子树

左子树：inorder [9]
右子树：inorder [15,20,7]

把相应的前序遍历的数组也加进来

左子树：preorder[9]，inorder [9]
右子树：preorder[20 15 7]，inorder [15,20,7]

现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题
然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可
```

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    int size = preorder.length;
    if(size <= 0){
        return null;
    }
    return preInBuildTree(preorder, inorder, 0, 0, size);
}

// preIndex 子树前序遍历开始下标
// inIndex  子树中序遍历开始下标
// size     子树节点个数
private TreeNode preInBuildTree(int[] preOrder, int[] inOrder, int preIndex, int inIndex, int size) {
    if(size <= 0){
        return null;
    }
    // 根节点
    TreeNode root = new TreeNode(preOrder[preIndex]);
    // 寻找根节点在中序遍历数组的下标
    int index = 0;
    for(int i = 0;i < size;++i){
        if(preOrder[preIndex] == inOrder[inIndex+i]){
            index = inIndex+i;
            break;
        }
    }
    // 左子树个数
    int leftSize = index - inIndex;
    // 右子树个数
    int rightSize = size - leftSize - 1;
    // 递归构建左子树
    root.left = preInBuildTree(preOrder, inOrder, preIndex+1, inIndex, leftSize);
    // 递归构建右子树
    root.right = preInBuildTree(preOrder, inOrder, preIndex+1+leftSize, index+1, rightSize);
    return root;
}
```

## 3. 思路-迭代
