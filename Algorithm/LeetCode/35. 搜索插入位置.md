
## 2. 思路

假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在 O(logn) 的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。

考虑这个插入的位置 pos，它成立的条件为：
```
nums[pos−1]<target≤nums[pos]
```
其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：在一个有序数组中找第一个大于等于 target 的下标。问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 target 的下标 。

```java
public int searchInsert(int[] nums, int target) {
    int size = nums.length;
    if(nums == null || size == 0){
        return 0;
    }
    if(target < nums[0]){
        return 0;
    }
    if(target > nums[size-1]){
        return size;
    }
    int left = 0;
    int right = size - 1;
    while(left <= right){
        int mid = left + ((right - left) / 2);
        if(nums[mid] == target){
            // 如果找到返回找到的下标
            return mid;
        }
        else if(nums[mid] > target){
            right = mid - 1;
        }
        else{
            left = mid + 1;
        }
    }
    // 如果没有找到返回插入位置
    return left;
}
```
