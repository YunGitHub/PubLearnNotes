
## 1. 什么是链表

链表是一种常见的基础数据结构。在链表中，每个节点包含指向下一个节点的指针，这些指针把节点连接成链状结构。在创建链表时无须事先知道链表的长度。链表节点的内存分配不是在创建链表时一次性地完成，而是每添加一个节点分配一次内存。当插入一个节点时，只需要为新节点分配内存，然后通过调整指针的指向来确保新节点被链接到链表中。这样，链表就能实现灵活的内存动态管理，可以充分地利用计算机的内存资源。

和数组相比，链表更适合用来存储一个大小动态变化的数据集。如果需要在一个数据集中频繁地添加新的数据并且不需要考虑数据的顺序，那么可以用链表来实现这个数据集。链表中的插入操作可以用 O(1) 的时间来实现。由于链表中的内存不是一次性分配的，因此链表节点在内存中的地址并不是连续的。如果想在链表中找到链表的第 i 个节点，就只能从头节点开始朝着指向下一个节点的指针遍历链表，它的时间效率为 O(n)。而在数组中，根据下标用 O(1) 的时间就能找到第 i 个元素。

## 2. 数据结构

在这我们先介绍单向链表，单向链表的节点包含指向下一个节点的指针，因此单向链表的节点可以定义为如下形式：
```java
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
    }
    ListNode(int val, ListNode next) {
        this.val = val; this.next = next;
    }
}
```

## 3. 哨兵节点

哨兵节点是为了简化处理链表边界条件而引入的附加链表节点。哨兵节点通常位于链表的头部，它的值没有任何意义。在一个有哨兵节点的链表中，从第 2 个节点开始才真正保存有意义的值。如下所示定义一个哨兵节点：
```java
ListNode dummy = new ListNode(0);
```
下面会介绍哨兵节点是如何简化链表插入以及删除操作的。

## 4. 插入

### 4.1 尾插入法

链表的一个基本操作是在链表的尾部添加一个节点。由于通常只有一个指向单向链表头节点的指针，因此需要遍历链表中的节点直至到达链表的尾部，然后在尾部添加一个节点：
```java
public ListNode append(ListNode head, int val) {
    ListNode newNode = new ListNode(val);
    if (head == null) {
        return newNode;
    }
    ListNode node = head;
    // 链表尾部
    while (node.next != null) {
        node = node.next;
    }
    // newNode 放在最后一个节点后
    node.next = newNode;
    return head;
}
```
上述代码中有一个值得注意的细节：当输入的链表头节点为 null 时，输入的链表为空。此时新添加的节点成为链表中唯一的节点，也就是链表的头节点。在这种情况下，我们改变了输入链表的头节点，因此在上述代码中有一条用来处理这种情况的 if 语句。

除了这种方法，我们还有一种可以在链表尾部添加节点的方法。首先创建一个哨兵节点，并把该节点当作链表的头节点，然后把原始的链表添加在哨兵节点的后面。当完成添加操作之后，再返回链表真正的头节点，也就是哨兵节点的下一个节点。这种思路的代码如下所示：
```java
public ListNode append(ListNode head, int val) {
    // 哨兵节点
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // 待插入节点
    ListNode newNode = new ListNode(val);
    // 遍历链表到达链表尾部
    ListNode node = dummy;
    while (node.next != null) {
        node = node.next;
    }
    // newNode 放在最后一个节点后
    node.next = newNode;
    return dummy.next;
}
```
由于将新创建的一个哨兵节点当作链表的头节点，链表无论如何也不会为空，因此不需要使用 if 语句来单独处理输入头节点 head 为 null 的情形。哨兵节点简化了代码的逻辑。

### 4.2 头插入法

```java
// 哨兵
ListNode dummy = new ListNode(0);
dummy.next = head;
// 新节点
ListNode newNode = new ListNode(val);
// 插入
newNode.next = dummy.next;
dummy.next = newNode;
```

## 5. 删除

下面讨论如何从链表中删除第 1 个为指定值的节点。通常为了删除一个节点，应该找到被删除节点的前一个节点，然后把该节点的 next 指针指向它下一个节点的下一个节点，这样下一个节点没有被其他节点引用，也就相当于被删除了。由于需要逐一遍历链表中的节点以便找到第 1 个指定值的节点，因此不难写出如下所示的代码：
```java
public ListNode delete(ListNode head, int val) {
    if (head == null) {
        return head;
    }
    // 如果第一个节点满足需求
    if (head.val == val) {
        return head.next;
    }
    // 非第一个节点满足需求
    ListNode node = head;
    while (node.next != null) {
        if (node.next.val == val) {
            node.next = node.next.next;
        }
        node = node.next;
    }
    return head;
}
```
在上述代码中有两条 if 语句，分别用于处理两个特殊情况：输入的链表为空；被删除的节点是原始链表的头节点。如果在链表的最前面添加一个哨兵节点作为头节点，那么链表就不为空，并且链表的头节点无论如何都不会被删除。因此，也可以用哨兵节点来简化从链表中删除节点的代码逻辑：
```java
public ListNode delete(ListNode head, int val) {
    // 哨兵节点
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode node = dummy;
    while (node.next != null) {
        if (node.next.val == val) {
            node.next = node.next.next;
        }
        node = node.next;
    }
    return dummy.next;
}
```

## 6. 反转链表

需要逐一遍历链表中的每一个节点，将当前节点 node 插入到哨兵节点的后面，因此我们还需要一个 nextNode 变量存储下一个要遍历的节点：
```java
public ListNode reverseList(ListNode head) {
    // 哨兵
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // 当前节点
    ListNode node = head;
    // 下一个节点
    ListNode nextNode;
    while(node != null){
        // 保存下一个节点的
        nextNode = node.next;
        // 插入节点到dummy节点后
        node.next = dummy.next;
        dummy.next = node;
        // 更新当前节点
        node = nextNode;
    }
    return dummy.next;
}
```

## 7. 双链表遍历

```java
while (l1 != null || l2 != null) {
    int v1 = l1 != null ? l1.val : 0;
    int v2 = l2 != null ? l2.val : 0;
    ...
    if (l1 != null) {
        l1 = l1.next;
    }
    if (l2 != null) {
        l2 = l2.next;
    }
}
```

## 8. 链表合并排序

```java
ListNode dummy = new ListNode(0);
ListNode node = dummy;
while (l1 != null || list2 != null) {
    int v1 = l1 != null ? l1.val : Integer.MAX_VALUE;
    int v2 = l2 != null ? l2.val : Integer.MAX_VALUE;
    if (v1 > v2) {
        node.next = l2;
        l2 = l2.next;
    } else {
        node.next = l1;
        l1 = l1.next;
    }
    node = node.next;
}
return dummy.next;
```
