## 1. 什么是回溯算法

回溯是一种算法技术，常用于组合问题中有技巧地穷尽所有可能组合的技术。回溯法可以看做是蛮力法的升级版，在解决问题时每一步都尝试所有可能的选项，最终找出所有可行的解决方案。回溯法通常用于存在多个可行解的情况。

回溯算法实际上是一个类似枚举的搜索尝试过程，在搜索尝试过程中寻找问题的解，当发现不满足求解条件时，就'回溯'返回，尝试别的路径。

## 2. 回溯是如何工作的？

在任何回溯问题中，该算法都试图找到一条有中间检查点可行解的路径。如果它们不能导致可行的解决方案，问题可以从检查点回溯到另一条路径来寻找解。考虑以下示例：


## 3. 回溯算法关键点

回溯算法关键点，从定义便能窥见一斑，关键点主要包括：
- 要结合递归遍历所有路径
- 每次回溯要能准确返回到检查点或状态点
- 尽可能今早判断出不满足的路径，也成为剪枝

## 4. 回溯算法注意事项

回溯是为了解决组合问题，是精进的穷举算法。需要注意：
- 遍历所有可能情况，不能出现遗漏
- 回溯不能再重复之前遍历的情况，否则会陷入死循环
- 避免出现错误的可行解
- 回溯往往会结合递归，递归要有返回条件

最后值得一提，回溯算法只适合搜索空间不大的场景，一般leetcode使用回溯求解场景，最后一般限制列表长度在20以下，这是因为当长度增大时，时间求解复杂度呈现的是指数级增长，所以不适合求解长度过长的问题。

## 5. 题型

## 5.1 组合



## 5.2 排列

### 5.2.1 不含重复元素的全排列

参考题目：[46. 全排列](https://leetcode.cn/problems/permutations/)

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    if(nums == null || nums.length == 0){
        return res;
    }
    List<Integer> tmpList = new ArrayList<>();
    backtrack(nums, tmpList, res);
    return res;
}

// 回溯 每一轮搜索选择一个未使用过数加入列表中
private void backtrack(int[] nums, List<Integer> tmpList, List<List<Integer>> res) {
    // 1. 终止条件 找到一种排列
    if (tmpList.size() == nums.length) {
        res.add(new ArrayList<>(tmpList));
        return;
    }
    for (int i = 0;i < nums.length;i++) {
        // 判断是否使用过
        if (tmpList.contains(nums[i])){
            continue;
        }
        tmpList.add(nums[i]);
        // 2. 递归函数
        backtrack(nums, tmpList, res);
        // 回溯
        tmpList.remove(tmpList.size()-1);
    }
}
```
### 5.2.2 包含重复元素的全排列

参考题目：[47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

```java
public List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    if(nums == null || nums.length == 0){
        return res;
    }
    List<Integer> tmpList = new ArrayList<>();
    boolean[] visited = new boolean[nums.length + 1];
    // 排序
    Arrays.sort(nums);
    backtrack(nums, tmpList, res, visited);
    return res;
}

// 回溯 每一轮搜索选择一个未使用过数加入列表中
private void backtrack(int[] nums, List<Integer> tmpList, List<List<Integer>> res, boolean[] visited) {
    // 1. 终止条件 找到一种排列
    if (tmpList.size() == nums.length) {
        res.add(new ArrayList<>(tmpList));
        return;
    }
    for (int i = 0;i < nums.length;i++) {
        // 跳过重复使用的
        if (visited[i]){
            continue;
        }
        // 重复元素保持原数组中的相对顺序
        // 永远都是按照重复元素的顺序使用元素即重复元素的第一个元素不使用,第二个元素不会使用
        if(i > 0 && nums[i] == nums[i-1] && !visited[i-1]){
            continue;
        }
        tmpList.add(nums[i]);
        visited[i] = true;
        // 2. 递归函数
        backtrack(nums, tmpList, res, visited);
        // 回溯
        visited[i] = false;
        tmpList.remove(tmpList.size()-1);
    }
}
```



参考：[Algorithm backtracking](http://www.zglg.work/algorithm/algorithm-backtracking/)
