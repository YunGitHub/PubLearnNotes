

## 1. 二叉树深度优先搜索

二叉树广度优先搜索可以细分为前序遍历、中序遍历、后序遍历：
- 中序遍历：按照左子树、根节点、右子树的顺序遍历(左中右)
- 前序遍历：按照根节点、左子树、右子树的顺序遍历(中左右)
- 后序遍历：按照左子树、右子树、根节点的顺序遍历(左右中)

> 这里的前中后，其实指的就是中间根节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。

如下图所示是一颗有7个节点的二叉树。根节点是1，同时它有4个叶子节点，分别是节点4、节点5、节点6、节点7：

![](1)

前中后序遍历顺序如下：
- 中序遍历：4、2、5、1、6、3、7
- 前序遍历：1、2、4、5、3、6、7
- 后序遍历：4、5、2、6、7、3、1

### 1.1 递归实现

#### 1.1.1 中序遍历

如果按照中序遍历的顺序，则先遍历左子树，然后遍历根节点、最后遍历右子树(左中右)。如上图所示，按照中序遍历，则先后遍历节点 4、2、5、1、6、3、7。

```java
void dfs(TreeNode node, List<Integer> nodes){
    // 终止条件
    if(node == null){
        return;
    }
    dfs(node.left, nodes);  // 左
    nodes.add(node.val);    // 中
    dfs(node.right, nodes); // 右
}
```

### 1.1.2 前序遍历

```java
void dfs(TreeNode node, List<Integer> nodes) {
    if (node == null) {
        return;
    }
    nodes.add(node.val);   // 中
    dfs(node.left, nodes); // 左
    dfs(node.right, nodes); // 右
}
```

### 1.1.3 后序遍历

```java
void dfs(TreeNode node, List<Integer> nodes){
    // 终止条件
    if(node == null){
        return;
    }
    dfs(node.left, nodes);  // 左
    dfs(node.right, nodes); // 右
    nodes.add(node.val);    // 中
}
```

### 1.2 迭代法

#### 1.2.1 中序遍历

```java
private void helper(TreeNode node, List<Integer> nodes) {
    Stack<TreeNode> stack = new Stack<>();
    while(node != null || !stack.isEmpty()) {
        // 遍历左子树
        while(node != null) {
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        nodes.add(node.val);
        // 遍历右子树
        node = node.right;
    }
}
```

#### 1.2.2 前序遍历

```java
private void helper(TreeNode node, List<Integer> nodes) {
    Stack<TreeNode> stack = new Stack<>();
    while(node != null || !stack.isEmpty()) {
        // 遍历左子树
        while(node != null) {
            nodes.add(node.val);
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        // 遍历右子树
        node = node.right;
    }
}
```

####  1.2.3 后序遍历

核心点：
- 判断节点的左右子树是否已经访问过
-

## 2. 二叉树广度优先搜索





相关题目：
- [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)
- [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
- [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
- [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
- [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
