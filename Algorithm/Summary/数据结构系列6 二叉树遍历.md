

## 1. 二叉树深度优先搜索

二叉树广度优先搜索可以细分为前序遍历、中序遍历、后序遍历：
- 中序遍历：按照左子树、根节点、右子树的顺序遍历(左中右)
- 前序遍历：按照根节点、左子树、右子树的顺序遍历(中左右)
- 后序遍历：按照左子树、右子树、根节点的顺序遍历(左右中)

> 这里的前中后，其实指的就是中间根节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。

如下图所示是一颗有7个节点的二叉树。根节点是1，同时它有4个叶子节点，分别是节点4、节点5、节点6、节点7：

![](1)

前中后序遍历顺序如下：
- 中序遍历：4、2、5、1、6、3、7
- 前序遍历：1、2、4、5、3、6、7
- 后序遍历：4、5、2、6、7、3、1

### 1.1 递归实现

#### 1.1.1 中序遍历

如果按照中序遍历的顺序，则先遍历左子树，然后遍历根节点、最后遍历右子树(左中右)。如上图所示，按照中序遍历，则先后遍历节点 4、2、5、1、6、3、7。

```java
void dfs(TreeNode node, List<Integer> nodes){
    // 终止条件
    if(node == null){
        return;
    }
    dfs(node.left, nodes);  // 左
    nodes.add(node.val);    // 中
    dfs(node.right, nodes); // 右
}
```

### 1.1.2 前序遍历

```java
void dfs(TreeNode node, List<Integer> nodes) {
    if (node == null) {
        return;
    }
    nodes.add(node.val);   // 中
    dfs(node.left, nodes); // 左
    dfs(node.right, nodes); // 右
}
```

### 1.1.3 后序遍历

```java
void dfs(TreeNode node, List<Integer> nodes){
    // 终止条件
    if(node == null){
        return;
    }
    dfs(node.left, nodes);  // 左
    dfs(node.right, nodes); // 右
    nodes.add(node.val);    // 中
}
```

### 1.2 迭代法

#### 1.2.1 中序遍历

```java
private void helper(TreeNode node, List<Integer> nodes) {
    Stack<TreeNode> stack = new Stack<>();
    while(node != null || !stack.isEmpty()) {
        // 遍历左子树
        while(node != null) {
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        nodes.add(node.val);
        // 遍历右子树
        node = node.right;
    }
}
```

#### 1.2.2 前序遍历

```java
private void helper(TreeNode node, List<Integer> nodes) {
    Stack<TreeNode> stack = new Stack<>();
    while(node != null || !stack.isEmpty()) {
        // 遍历左子树
        while(node != null) {
            nodes.add(node.val);
            stack.push(node);
            node = node.left;
        }
        node = stack.pop();
        // 遍历右子树
        node = node.right;
    }
}
```

####  1.2.3 后序遍历

核心点：
- 判断节点的左右子树是否已经访问过
-

## 2. 二叉树广度优先搜索

### 2.1 层次遍历

思路：将根节点加入队列，当队列不为空的时候循环队列。每次 while 循环拿到当前队列的大小，这个大小就是当前层的节点个数。然后 for 循环遍历当前层的每个节点，将节点值加入到输出列表 res 中，如果这个节点存在左右子节点则将左右节点加入队列。
复杂度分析：时间复杂度 O(n)，每个节点遍历一次，故渐进时间复杂度为 O(n)。空间复杂度O(n)，队列中元素的个数不超过 n 个
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null)  {
        return res;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    List<Integer> levelList = new ArrayList<>();
    while(!queue.isEmpty()) {
        int curCount = queue.size();
        // 开始遍历当前层
        for(int index = 0;index < curCount;index++) {
            TreeNode node = queue.remove();
            levelList.add(node.val);
            // 左子节点加入队列
            if (node.left != null) {
                queue.add(node.left);
            }
            // 右子节点加入队列
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        // 结束遍历当前层
        List<Integer> tmpList = new ArrayList<>(levelList);
        res.add(tmpList);
        levelList.clear();
    }
    return res;
}
```
### 2.2 层次遍历II

这道题和 [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) 相似。不同之处在于，第 102 题要求从上到下输出每一层的节点值，而这道题要求从下到上输出每一层的节点值。除了输出顺序不同以外，这两道题的思路是相同的，都可以使用广度优先搜索进行层次遍历。



相关题目：
- [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)
- [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
- [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
- [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
- [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
