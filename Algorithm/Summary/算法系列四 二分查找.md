
## 1. 什么是二分查找

在一个长度为 n 的数组中查找一个数字，如果逐一扫描数组中的每个数字，那么需要 O(n) 的时间。但如果数组是排序的(通常按照递增的顺序排序)，那么可以采用二分查找算法进行优化。

可以取出位于数组中间的数字并和目标数字比较。如果中间数字正好等于目标数字，那么就找到了目标数字。如果中间数字大于目标数字，那么只需要查找数组的前半部分，这是因为数组是排序的，后半部分的数字都大于或等于中间数字，所以一定都大于目标数字，也就没有必要再在后半部分查找。如果中间数字小于目标数字，那么接下来只需要查找数组的后半部分，这是因为排序数组的前半部分的数字都小于或等于中间数字，所以一定都小于目标数字，也就没有必要再在前半部分查找。

## 2. 查找原理

如果排序数组 nums 中包含目标数字 target，那么返回 target 在数组中的下标，否则返回 -1。二分查找的做法是在下标为 left 和 right 之间的子数组 `[left, right]` 中查找。left 是查找范围子数组最左边的下标，初始化为 0，right 是查找范围子数组最右边的下标，初始化为数组的最后一个下标，因此最初的查找范围为整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半：
- 如果中间数字刚好等于目标数字 target，那么可以返回中间数字的下标 mid。
- 如果中间数字大于目标数字，那么只需要在当前查找范围的前半部分查找。将 right 指向当前中间数字的前一个数字，即下标为 mid-1 的位置，下一轮查找范围(还是下标从 left 到 right 的子数组)就是当前查找范围的前半部分。
- 如果中间数字小于目标数字的情形则刚好相反，只需要在当前查找范围的后半部分查找。将 left 指向当前中间数字的下一个数字，即下标为 mid+1 的位置，下一轮查找范围(还是下标从 left 到 right 的子数组)就是当前查找范围的后半部分。

二分查找的条件是查找范围不为空，即 left ≤ right。当 left 等于 right 时，查找范围是长度为 1 的子数组。长度为 1 的子数组仍然是一个有效的查找范围，但当 left 大于 right 时这两个下标就不能形成一个有效的查找返回，因此 while 循环的条件是 left 小于或等于 right。

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    // 在区间 [left, right] 中查找
    while (left <= right){
        // int mid = (left + right) / 2;
        // 计算中间点 防止溢出
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        if (num == target){
            // 如果中间数字等于目标数字 target 直接返回下标 mid
            return mid;
        } else if (num > target) {
            // 如果中间数字大于目标数字，那么只需要在当前查找范围的前半部分查找
            // 将 right 指向当前中间数字的前一个数字
            right = mid - 1;
        } else {
            // 如果中间数字小于目标数字，那么只需要在当前查找范围的后半部分查找
            // 将 left 指向当前中间数字的下一个数字
            left = mid + 1;
        }
    }
    return -1;
}
```
> 使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left 与 right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。

二分查找算法每次将查找范围减少一半，因此对于一个长度为 n 的数组可能需要 O(logn) 次查找，每次查找只需要比较当前查找范围的中间数字和目标数字，在 O(1) 的时间可以完成，因此二分查找算法的时间复杂度是 O(logn)。

## 3. 题型

### 3.1 在有序数组中二分查找

#### 3.1.1 搜索插入位置

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/submissions/)

```java
public int searchInsert(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while(left <= right){
        int mid = left + ((right - left) / 2);
        if(nums[mid] == target){
            // 如果找到返回找到的下标
            return mid;
        }
        else if(nums[mid] > target){
            right = mid - 1;
        }
        else{
            left = mid + 1;
        }
    }
    // 如果没有找到返回插入位置
    return left;
}
```

#### 3.1.2 山脉数组的峰顶索引

[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

```java
public int peakIndexInMountainArray(int[] arr) {
    // 第一个数肯定不是峰值
    int left = 1;
    // 最后一个数肯定不是峰值
    int right = arr.length - 2;
    while (left <= right) {
        int mid = left + ((right - left) / 2);
        if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
            // 大于前一个数 & 大于后一个数 峰值
            return mid;
        } else if (arr[mid] > arr[mid - 1]) {
            // 大于前一个数 & 小于后一个数 峰值在后半部分
            left = mid + 1;
        } else {
            // 小于前一个数 & 大于后一个数 峰值在前半部分
            right = mid - 1;
        }
    }
    return -1;
}
```


参考:
- https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
