---
layout: post
author: wy
title: 算法系列1 字符串匹配之蛮力匹配
date: 2022-07-03 13:40:21
tags:
  - 算法系列

categories: 算法
permalink: computer-algorithms-brute-force-string-matching
---

## 1. 引言

字符串匹配是数据库开发和文字处理软件的关键。幸运的是所有现代编程语言和字符串库函数，帮助我们的日常工作。不过理解他们的原理还是比较重要的。字符串算法主要可以分为几类。字符串匹配就是其中之一。当我们提到字符串匹配算法，最基本的方法就是所谓的蛮力解法，我们需要检查匹配串中的每一个字符是否和文本串相匹配（在文本串中寻找匹配串）。一般来说匹配串短于文本串。我们需要做的就是回答这个匹配串是否出现在文本串中。

## 2. 概述

字符串蛮力匹配法的原理非常简单。我们必须检查匹配串的第一个字符与文本串的第一个字符是否相匹配，如下图片所述：

![](https://github.com/sjf0115/ImageBucket/blob/main/Algorithm/computer-algorithms-brute-force-string-matching-1.png?raw=true)

我们通过比较文本串的和匹配串的第一个字符来开始匹配。如果他们不匹配我们移向文本串的第二个字符。现在我们比较匹配串的第一个字符和文本串第二个字符。如果他们不匹配我们继续向前移动，直到我们遇到一个相匹配的或直到我们到达文本串的最后。

![](https://github.com/sjf0115/ImageBucket/blob/main/Algorithm/computer-algorithms-brute-force-string-matching-2.png?raw=true)

因为文本串第一个字符和匹配串的第一个字符不匹配，我们向前移动到文本串的的第二个字符。现在我们比较文本串的第二个字符和匹配串的第一个字符!

假设第一个字符匹配，我们移向匹配串的第二个字符去和文本串的下一个字符比较。如下面图片所示：

![](https://github.com/sjf0115/ImageBucket/blob/main/Algorithm/computer-algorithms-brute-force-string-matching-3.png?raw=true)

如果文本串的一个字符和匹配串的第一个字符相匹配，我们向前移动到匹配串第二个字符和文本串的下一个字符做匹配。

如果仅仅是因为匹配串的第一个字符与文本串的某个字符相匹配，那并不意味着这个匹配串出现在文本串中，也仅仅是第一个字符出现在文本串中，其他说明不了。我们必须向前移动匹配串，看看完整的匹配串是否包含在文本串中。

![](https://github.com/sjf0115/ImageBucket/blob/main/Algorithm/computer-algorithms-brute-force-string-matching-4.png?raw=true)

## 3. 代码实现

```java
public class BruteForceSubString {
    // 蛮力匹配
    private static int SubString(String text, String pattern){
        // 文本串长度
        int m = text.length();
        // 匹配串长度
        int n = pattern.length();
        // 蛮力匹配
        // 判断以下标 t 元素开始的子串是否匹配
        for(int t = 0;t < m - n;t++) {
            // 判断匹配串每个元素是否匹配
            int p;
            for (p = 0;p < n;p++) {
                if (pattern.charAt(p) != text.charAt(t+p)) {
                    break;
                }
            }
            if (p == n) {
                return t;
            }
        }//for
        return -1;
    }

    public static void main(String[] args) {
        String text = "hello world!";
        String pattern = "o wo";
        int result = SubString(text, pattern);
        System.out.println(result);
    }
}
```
就像我说的这个算法是缓慢的。实际上每一个算法，只要在它的名字中包含'蛮力'二字，这个算法都是很缓慢的，其时间复杂度是O(n*m)。这里 m 是文本串的长度，而 n 是匹配串的长度。

原文:[Computer Algorithms: Brute Force String Matching](http://www.stoimen.com/blog/2012/03/27/computer-algorithms-brute-force-string-matching/)
