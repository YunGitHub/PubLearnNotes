
## 1. 什么是二分查找

在一个长度为 n 的数组中查找一个数字，如果逐一扫描数组中的每个数字，那么需要 O(n) 的时间。但如果数组是排序的(通常按照递增的顺序排序)，那么可以采用二分查找算法进行优化。

可以取出位于数组中间的数字并和目标数字比较。如果中间数字正好等于目标数字，那么就找到了目标数字。如果中间数字大于目标数字，那么只需要查找数组的前半部分，这是因为数组是排序的，后半部分的数字都大于或等于中间数字，所以一定都大于目标数字，也就没有必要再在后半部分查找。如果中间数字小于目标数字，那么接下来只需要查找数组的后半部分，这是因为排序数组的前半部分的数字都小于或等于中间数字，所以一定都小于目标数字，也就没有必要再在前半部分查找。

## 2. 查找原理

如果排序数组 nums 中包含目标数字 target，那么返回 target 在数组中的下标，否则返回 -1。二分查找的做法是在下标为 left 和 right 之间的子数组 `[left, right]` 中查找。left 是查找范围子数组最左边的下标，初始化为 0，right 是查找范围子数组最右边的下标，初始化为数组的最后一个下标，因此最初的查找范围为整个数组。每次取查找范围的中点 mid，比较 nums[mid] 和 target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和 target 的大小关系将查找范围缩小一半：
- 如果中间数字刚好等于目标数字 target，那么可以返回中间数字的下标 mid。
- 如果中间数字大于目标数字，那么只需要在当前查找范围的前半部分查找。将 right 指向当前中间数字的前一个数字，即下标为 mid-1 的位置，下一轮查找范围(还是下标从 left 到 right 的子数组)就是当前查找范围的前半部分。
- 如果中间数字小于目标数字的情形则刚好相反，只需要在当前查找范围的后半部分查找。将 left 指向当前中间数字的下一个数字，即下标为 mid+1 的位置，下一轮查找范围(还是下标从 left 到 right 的子数组)就是当前查找范围的后半部分。

二分查找的条件是查找范围不为空，即 left ≤ right。当 left 等于 right 时，查找范围是长度为 1 的子数组。长度为 1 的子数组仍然是一个有效的查找范围，但当 left 大于 right 时这两个下标就不能形成一个有效的查找返回，因此 while 循环的条件是 left 小于或等于 right。

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    // 在区间 [left, right] 中查找
    while (left <= right){
        // int mid = (left + right) / 2;
        // 计算中间点 防止溢出
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        if (num == target){
            // 如果中间数字等于目标数字 target 直接返回下标 mid
            return mid;
        } else if (num > target) {
            // 如果中间数字大于目标数字，那么只需要在当前查找范围的前半部分查找
            // 将 right 指向当前中间数字的前一个数字
            right = mid - 1;
        } else {
            // 如果中间数字小于目标数字，那么只需要在当前查找范围的后半部分查找
            // 将 left 指向当前中间数字的下一个数字
            left = mid + 1;
        }
    }
    return -1;
}
```
> 使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left 与 right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。

二分查找算法每次将查找范围减少一半，因此对于一个长度为 n 的数组可能需要 O(logn) 次查找，每次查找只需要比较当前查找范围的中间数字和目标数字，在 O(1) 的时间可以完成，因此二分查找算法的时间复杂度是 O(logn)。

## 3. 有序数组中查找

### 3.1 不包含重复元素

有序数组不包含重复元素寻找给定值：
```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        if (num == target){
            return mid;
        } else if (num > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```
有序数组不包含重复元素寻找大于给定值：插入位置
```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        if (num == target){
            return mid;
        } else if (num > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```
有序数组不包含重复元素寻找小于给定值
```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        if (num == target){
            return mid;
        } else if (num > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return right;
}
```

### 3.2 包含重复元素

#### 3.2.1 查找第一个等于给定值的元素/位置

```java
public int binarySearch(int[] nums, int target) {
  int left = 0;
  int right = nums.length - 1;
  while (left <= right) {
      int mid =  left + ((right - left) >> 1);
      if (nums[mid] > target) {
          // 中间元素大于目标值 目标值在 [left, mid-1] 区间内
          right = mid - 1;
      } else if (nums[mid] < target) {
          // 中间元素小于目标值 目标值在 [mid+1, right] 区间内
          left = mid + 1;
      } else {
          // 中间元素等于目标值 需要判断是否是第一个等于目标值
          if ((mid == 0) || (nums[mid - 1] != target)) {
              // 第一个元素或者前一个元素不等于target
              return mid;
          } else {
              // 不是第一个 目标值在前面 在 [left, mid-1] 区间内
              right = mid - 1;
          }
      }
  }
  return -1;
}
```
nums[mid] 跟要查找的 target 的大小关系有三种情况：大于、小于、等于。对于 nums[mid] > target 的情况，我们需要更新 right=mid-1；对于 nums[mid] < target 的情况，我们需要更新 left=mid+1。这两点都很好理解。那当 nums[mid] = target 的时候应该如何处理呢？如果我们查找的是任意一个值等于给定值的元素，当 nums[mid] 等于要查找的值时，nums[mid]就是我们要找的元素。但是，如果我们求解的是第一个等于给定值的元素，当 nums[mid] 等于要查找的值时，我们就需要确认一下这个 nums[mid] 是不是第一个值等于给定值的元素。如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 nums[mid]的前一个元素 nums[mid-1] 不等于 target，那也说明 nums[mid] 就是我们要找的第一个值等于给定值的元素。如果经过检查之后发现 nums[mid] 前面的一个元素 nums[mid-1] 也等于 target，那说明此时的 nums[mid] 肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 right=mid-1，因为要找的元素肯定出现在 [left, mid-1] 之间。

#### 3.2.2 查找最后一个值等于给定值的元素

```java
public int binarySearch(int[] nums, int target) {
  int left = 0;
  int right = nums.length - 1;
  while (left <= right) {
      int mid =  left + ((right - left) >> 1);
      if (nums[mid] > target) {
          // 中间元素大于目标值 目标值在 [left, mid-1] 区间内
          right = mid - 1;
      } else if (nums[mid] < target) {
          // 中间元素小于目标值 目标值在 [mid+1, right] 区间内
          left = mid + 1;
      } else {
          // 中间元素等于目标值 需要判断是否是最后一个等于目标值
          if ((mid == nums.length - 1) || (nums[mid + 1] != target)) {
              // 最后一个元素或者中间元素的后一个不等于target
              return mid;
          } else {
              // 不是最后一个 目标值在后面 在 [mid+1, right] 区间内
              left = mid + 1;
          }
      }
  }
  // 目标值不存在
  return -1;
}
```
如果 nums[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 nums[mid] 的后一个元素 nums[mid+1] 不等于 target，那也说明 nums[mid] 就是我们要找的最后一个值等于给定值的元素。如果 nums[mid] 后面的一个元素 nums[mid+1] 也等于 target，那说明当前的这个 nums[mid] 并不是最后一个值等于给定值的元素。我们就更新 left=mid+1，因为要找的元素肯定出现在 [mid+1, right] 之间。

#### 3.2.3 查找第一个大于等于给定值的元素

```java
public int bsearch(int[] a, int n, int target) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (nums[mid] >= target) {
      if ((mid == 0) || (a[mid - 1] < target)) return mid;
      else high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
```
如果 nums[mid] 小于要查找的值 target，那要查找的值肯定在 [mid+1, high] 之间，所以，我们更新 low=mid+1。对于 nums[mid] 大于等于给定值 target 的情况，我们要先看下这个 nums[mid] 是不是我们要找的第一个值大于等于给定值的元素。如果 nums[mid] 前面已经没有元素，或者前面一个元素小于要查找的值 target，那 nums[mid] 就是我们要找的元素。如果 nums[mid-1] 也大于等于要查找的值 target，那说明要查找的元素在 [low, mid-1] 之间，所以，我们将 high 更新为 mid-1。

#### 3.2.4 查找最后一个小于等于给定值的元素

```java
public int bsearch7(int[] a, int n, int target) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (nums[mid] > target) {
      high = mid - 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] > target)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
```
## 4. 旋转数组中查找

### 4.1 不包含重复元素

对于有序数组，可以使用二分查找的方法查找元素。旋转数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。可以发现将数组从中间分开成左右两部分，其中一定有一部分的数组是有序的。拿 `[4,5,6,7,0,1,2]` 举例来说，从 6 这个位置分开以后数组变成了 `[4, 5, 6]` 和 `[7, 0, 1, 2]` 两部分，其中左边 `[4, 5, 6]` 这个部分的数组是有序的。可以将 mid 作为分割位置，从而将数组分割为 `[left, mid]` 和 `[mid + 1, right]` 两部分。根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：
- 如果 `nums[left] <= nums[mid]` 即 `[left, mid]` 是有序数组
  -  如果 target 满足：`nums[left] <= target < nums[mid]`，那么搜索范围缩小至 `[left, mid-1]`，否则在 `[mid+1, right]` 中寻找。
- 如果 `nums[left] > nums[mid]` 即 `[mid, right]` 是有序数组
  - 如果 target 满足：`nums[mid] < target <= nums[right]`，那么搜索范围缩小至 `[mid+1, right]`，否则在 `[left, mid-1]` 中寻找。

```java
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid =  left + ((right - left) >> 1);
        // 找到目标
        if (target == nums[mid]) {
            return mid;
        }
        // 缩小搜索范围
        if (nums[left] <= nums[mid]) {
            // 中间元素大于等于首元素 [left, mid] 有序
            if (nums[left] <= target && target < nums[mid]) {
                // nums[left] <= target < nums[mid] 搜索范围缩小至 [left, mid-1]
                right = mid - 1;
            } else {
                // 搜索范围缩小至 [mid+1, right]
                left = mid + 1;
            }
        } else {
            // 中间元素小于首元素 [mid, right] 有序
            if (nums[mid] < target && target <= nums[right]) {
                // nums[mid] < target <= nums[right] 搜索范围缩小至 [mid+1, right]
                left = mid + 1;
            } else {
                // 搜索范围缩小至 [left, mid-1]
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

参考：[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

### 4.2 包含重复元素

与不含重复元素的类似，只是多了一个去掉一个重复的干扰项的情况。当 `nums[left] == nums[mid]` 时，无法区分 `[left, mid]` 有序还是 `[mid, right]` 有序。解决方案是让 left++ 即可，排序重复元素的干扰，其余部分完全相同。

```java
// 在旋转排序有重复的数组中二分查找
public boolean binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    // 在区间 [left, right] 中查找
    while (left <= right){
        // 计算中间点 防止溢出
        int mid = left + (right - left) / 2;
        // 1. 如果中间数字等于目标数字 target 直接返回
        if (nums[mid] == target) {
            return true;
        }

        // 2. 核心点: 无法区分 [left, mid] 有序还是 [mid, right] 有序 去掉一个重复的干扰项
        if (nums[left] == nums[mid]) {
            left++;
            continue;
        }

        // 3. 旋转排序数组查找
        if (nums[left] < nums[mid]) {
            // 中间元素大于等于首元素 [left, mid] 有序
            if (nums[left] <= target && target < nums[mid]) {
                // nums[left] <= target < nums[mid] 搜索范围缩小至 [left, mid-1]
                right = mid - 1;
            } else {
                // 搜索范围缩小至 [mid+1, right]
                left = mid + 1;
            }
        } else {
            // 中间元素小于首元素 [mid, right] 有序
            if (nums[mid] < target && target <= nums[right]) {
                // nums[mid] < target <= nums[right] 搜索范围缩小至 [mid+1, right]
                left = mid + 1;
            } else {
                // 搜索范围缩小至 [left, mid-1]
                right = mid - 1;
            }
        }
    }
    return false;
}
```
> [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)


## 5. 题型

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/submissions/)
[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

参考:
- https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
