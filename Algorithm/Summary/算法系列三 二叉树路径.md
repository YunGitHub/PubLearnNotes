
## 1. 深度

### 1.1 最大深度

#### 1.1.1 递归-深度优先遍历

如果我们知道了左子树和右子树的最大深度 leftMaxDepth 和 rightMaxDepth，那么该二叉树的最大深度为：
```java
max(leftMaxDepth, rightMaxDepth) + 1;
```
在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，那么当前节点的最大深度等于左右子树的最大深度 + 1：
```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 左子树的最大深度
    int leftMaxDepth = maxDepth(root.left);
    // 右子树的最大深度
    int rightMaxDepth = maxDepth(root.right);
    // 当前节点的最大深度=左右子树的最大深度 + 1
    int maxDepth = Math.max(leftMaxDepth, rightMaxDepth) + 1;
    return maxDepth;
}
```

#### 1.1.2 迭代-广度优先遍历

广度优先遍历使用队列里存放当前层的所有节点。每次遍历下一层节点时，不同于广度优先遍历每次只从队列里拿出一个节点，在这需要将队列里的所有节点都拿出来进行遍历，这样能保证每次遍历完时队列里存放的是当前层的所有节点，即我们是一层一层地进行遍历，最后我们用一个变量 maxDepth 来维护遍历的层数：
```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    int maxDepth = 0;
    while (!queue.isEmpty()) {
        // 当前层节点个数
        int levelSize = queue.size();
        // 遍历当前层节点
        for (int index = 0;index < levelSize;index ++) {
            TreeNode node = queue.remove();
            // 下一层节点加入队列
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        maxDepth ++;
    }
    return maxDepth;
}
```

### 1.2 最小深度

> 注意题意:最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

#### 1.2.1 递归-深度优先遍历

对于每一个叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题：
- 只有左子树时，当前节点的最小深度等于右子树最小深度+1
- 只有右子树时，当前节点的最小深度等于左子树最小深度+1
- 左右子树均有或者均没有时，当前节点的最小深度等于左右子树的最小深度+1
```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 左子树的最小深度
    int leftMinDepth = minDepth(root.left);
    // 右子树的最小深度
    int rightMinDepth = minDepth(root.right);
    // 只有左子树 当前节点的最小深度=右子树最小深度+1
    if (rightMinDepth == 0 && leftMinDepth != 0) {
        return leftMinDepth + 1;
    }
    // 只有右子树 当前节点的最小深度=左子树最小深度+1
    if (leftMinDepth == 0 && rightMinDepth != 0) {
        return rightMinDepth + 1;
    }
    // 左右子树均有或者均没有 当前节点的最小深度=左右子树的最小深度 + 1
    int minDepth = Math.min(leftMinDepth, rightMinDepth) + 1;
    return minDepth;
}
```
#### 1.2.2 迭代-广度优先遍历

当我们找到一个叶子节点时，这个叶子节点的深度就是整个树的最小深度。广度优先遍历的性质保证了最先搜索到的叶子节点的深度一定最小：
```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    int minDepth = 0;
    while (!queue.isEmpty()) {
        minDepth ++;
        // 当前层节点个数
        int levelSize = queue.size();
        // 遍历当前层节点
        for (int index = 0;index < levelSize;index ++) {
            TreeNode node = queue.remove();
            // 找到一个最近叶子节点
            if (node.left == null && node.right == null) {
                return minDepth;
            }
            // 下一层节点加入队列
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }
    return minDepth;
}
```
