
最近发现离线任务对一个增量 Hive 表的查询越来越慢，这引起了我的注意，我在 cmd 窗口手动执行 count 操作查询发现，速度确实很慢，才不到五千万的数据，居然需要 300s，这显然是有问题的，我推测可能是有小文件。我去 HDFS 目录查看了一下该目录：

![](1)

发现确实有很多小文件，有 480 个小文件，我觉得我找到了问题所在，那么合并一下小文件吧：
```sql
insert into test
select * from table
distribute by floor (rand()*5);
```

这里使用 distribute by 进行了一个小文件的合并，通过 `rand() * 5`，保证了从 map 端输出的数据，最多到 5 个 reducer，将小文件数量控制了下来，现在只有 3 个文件了:

![](2)

合并小文件后，再次做同样的查询，15s 就完成了。确实忽略了，增量数据会导致小文件，应该在当初做的时候就做定时的小文件合并，而不是等到现在才发现。因为这个表每天是有增量数据进去的，增量数据会单独生成一个文件，因为增量数据本身不大，日积月累就形成了大量小文件。不仅对 namenode 的内存造成压力，对 map 端的小文件合并也有很大压力。

## 1. 小文件产生的原因

- 动态分区插入数据的时候，会产生大量的小文件；
- 数据源本身就包含有大量的小文件；
- 做增量导入，比如Sqoop数据导入，一些增量insert等；
- 分桶表，分桶表通常也会遇到小文件，本质上还是增量导入的问题；
- 可以修改的表，这种 Hive 表是可以进行修改的，通过配置 stored as orc TBLPROPERTIES ("transactional"="true")，这种表最坑，每天都会有一个快照，到后面 10G 大小的数据，表文件体积可以达到 600G，时间越长越大；

小文件的问题有很多，实际中各种原因，由于自己的不小心，前期没有做好预防都会产生大量小文件，让线上的离线任务神不知鬼不觉，越跑越慢。

## 2. 小文件的危害

- 给 namenode 内存中 fsImage 的合并造成压力，如果 namenode 内存使用完了，这个集群将不能再存储文件了；
- 虽然 map 阶段都设置了小文件合并，org.apache.hadoop.hive.ql.io.CombineHiveInputFormat，太多小文件导致合并时间较长，查询缓慢；

## 3. 小文件的解决方案

彻底解决小文件，分为了两个方向，一个是小文件的预防，一个是大量小文件问题已经出现了，我们该怎么解决。

### 3.1 小文件的预防

有些公司用的版本不同，低版本可能有些配置不一样，最好检查一下上面这些配置是否设置，然后根据自己的实际集群情况进行设置。

小文件的预防，主要还是要根据小文件的产生原因，来进行预防。
- 动态分区插入的时候，保证有静态分区，不要误判导致产生大量分区，大量分区加起来，自然就有大量小文件；
- 如果源表是有大量小文件的，在导入数据到目标表的时候，如果只是insert into dis select * from origin的话，目标表通常也有很多小文件。如果有分区，比如dt, hour，可以使用distribute by dt, hour，保证每个小时的数据在一个 reduce 里面；
- 类似sqoop增量导入，还有hive一些表的查询增量导入，这些肯定是有小文件的，需要进行一周甚至一天定时任务的小文件合并。

### 3.2 小文件的解决

上面是平时开发数据任务时候，小文件的预防，但如果由于我们的大意，小文件问题已经产生了，就需要解决了。通常就是insert overwrite了。
```sql
insert overwrite table test [partition(hour=...)] select * from test distribute by floor (rand()*5);
```
注：这个语句把test表的数据查询出来，overwrite覆盖test表，不用担心如果overwrite失败，数据没了，这里面是有事物性保证的，可以观察一下执行的时候，在test表hdfs文件目录下面有个临时文件夹。如果是分区表，加上partition，表示对该分区进行overwrite。

如果是orc格式存储的表，还可以使用alter table test [partition(...)] concatenate进行小文件的合并，不过这种方法仅仅适用于orc格式存储的表。

原文:[彻底解决Hive小文件问题](https://mp.weixin.qq.com/s/V56pPo6LogRMD_CHp9zHGA)
